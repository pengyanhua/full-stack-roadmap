# slice

::: info æ–‡ä»¶ä¿¡æ¯
- ğŸ“„ åŸæ–‡ä»¶ï¼š`slice.go`
- ğŸ”¤ è¯­è¨€ï¼šgo
:::

## å®Œæ•´ä»£ç 

```go
package utils

// ----------------------------------------------------------
// åˆ‡ç‰‡å·¥å…·å‡½æ•°
// ----------------------------------------------------------

// Contains æ£€æŸ¥åˆ‡ç‰‡æ˜¯å¦åŒ…å«å…ƒç´ 
func Contains[T comparable](slice []T, item T) bool {
	for _, v := range slice {
		if v == item {
			return true
		}
	}
	return false
}

// Filter è¿‡æ»¤åˆ‡ç‰‡
func Filter[T any](slice []T, predicate func(T) bool) []T {
	result := make([]T, 0)
	for _, v := range slice {
		if predicate(v) {
			result = append(result, v)
		}
	}
	return result
}

// Map æ˜ å°„åˆ‡ç‰‡
func Map[T, U any](slice []T, mapper func(T) U) []U {
	result := make([]U, len(slice))
	for i, v := range slice {
		result[i] = mapper(v)
	}
	return result
}

// Reduce å½’çº¦åˆ‡ç‰‡
func Reduce[T, U any](slice []T, initial U, reducer func(U, T) U) U {
	result := initial
	for _, v := range slice {
		result = reducer(result, v)
	}
	return result
}

// Unique å»é‡
func Unique[T comparable](slice []T) []T {
	seen := make(map[T]bool)
	result := make([]T, 0)
	for _, v := range slice {
		if !seen[v] {
			seen[v] = true
			result = append(result, v)
		}
	}
	return result
}
```
