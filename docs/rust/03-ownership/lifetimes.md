# lifetimes.rs

::: info æ–‡ä»¶ä¿¡æ¯
- ğŸ“„ åŸæ–‡ä»¶ï¼š`03_lifetimes.rs`
- ğŸ”¤ è¯­è¨€ï¼šrust
:::

## å®Œæ•´ä»£ç 

```rust
// ============================================================
//                      ç”Ÿå‘½å‘¨æœŸï¼ˆLifetimesï¼‰
// ============================================================
// ç”Ÿå‘½å‘¨æœŸæ˜¯ Rust ç¡®ä¿å¼•ç”¨æœ‰æ•ˆçš„æœºåˆ¶
// å¤§å¤šæ•°æƒ…å†µä¸‹ç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨æ–­ï¼ˆç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼‰
// åªæœ‰å½“ç¼–è¯‘å™¨æ— æ³•æ¨æ–­æ—¶æ‰éœ€è¦æ‰‹åŠ¨æ ‡æ³¨
//
// ã€æ ¸å¿ƒæ¦‚å¿µã€‘ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸æ”¹å˜å¼•ç”¨çš„å®é™…ç”Ÿå‘½å‘¨æœŸï¼Œ
//             å®ƒåªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨å¤šä¸ªå¼•ç”¨ä¹‹é—´çš„å…³ç³»

fn main() {
    println!("=== ç”Ÿå‘½å‘¨æœŸ ===");

    // ----------------------------------------------------------
    // 1. ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸ
    // ----------------------------------------------------------
    // å½“å‡½æ•°è¿”å›å¼•ç”¨æ—¶ï¼Œç¼–è¯‘å™¨éœ€è¦çŸ¥é“è¿”å›çš„å¼•ç”¨æœ‰æ•ˆå¤šä¹…
    // å¦åˆ™å¯èƒ½å‡ºç°æ‚¬å‚å¼•ç”¨

    let string1 = String::from("é•¿å­—ç¬¦ä¸²");
    let result;
    {
        let string2 = String::from("çŸ­");
        result = longest(string1.as_str(), string2.as_str());
        println!("æ›´é•¿çš„: {}", result);
    }
    // å¦‚æœ result å¼•ç”¨äº† string2ï¼Œè¿™é‡Œå°±ä¼šæ‚¬å‚
    // ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å¸®åŠ©ç¼–è¯‘å™¨æ£€æŸ¥è¿™ç§æƒ…å†µ

    // ----------------------------------------------------------
    // 2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•
    // ----------------------------------------------------------
    // ä½¿ç”¨ 'a, 'b ç­‰å‘½åï¼ˆä»¥å•å¼•å·å¼€å¤´ï¼‰
    // 'a è¯»ä½œ"ç”Ÿå‘½å‘¨æœŸ a"
    // æ ‡æ³¨åœ¨ & åé¢ï¼š&'a str, &'a mut String

    let s1 = String::from("hello");
    let s2 = String::from("hi");
    let longer = longest(&s1, &s2);
    println!("è¾ƒé•¿: {}", longer);

    // ----------------------------------------------------------
    // 3. ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼ˆElision Rulesï¼‰
    // ----------------------------------------------------------
    // ç¼–è¯‘å™¨è‡ªåŠ¨åº”ç”¨ä¸‰æ¡è§„åˆ™ï¼Œèƒ½æ¨æ–­å‡ºå°±ä¸éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ï¼š
    //
    // è§„åˆ™1: æ¯ä¸ªå¼•ç”¨å‚æ•°è·å¾—ç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸ
    //   fn foo(x: &str, y: &str) â†’ fn foo<'a, 'b>(x: &'a str, y: &'b str)
    //
    // è§„åˆ™2: å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œè¾“å‡ºç”Ÿå‘½å‘¨æœŸç­‰äºå®ƒ
    //   fn foo(x: &str) -> &str â†’ fn foo<'a>(x: &'a str) -> &'a str
    //
    // è§„åˆ™3: å¦‚æœæœ‰ &self æˆ– &mut selfï¼Œè¾“å‡ºç”Ÿå‘½å‘¨æœŸç­‰äº self
    //   fn method(&self, x: &str) -> &str â†’ è¾“å‡ºç”Ÿå‘½å‘¨æœŸ = self

    // è‡ªåŠ¨æ¨æ–­çš„ä¾‹å­ï¼ˆä¸éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ï¼‰ï¼š
    let s = String::from("hello world");
    let first = first_word(&s);  // ç¼–è¯‘å™¨çŸ¥é“è¿”å›å€¼ç”Ÿå‘½å‘¨æœŸ = å‚æ•°
    println!("ç¬¬ä¸€ä¸ªè¯: {}", first);

    // ----------------------------------------------------------
    // 4. ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
    // ----------------------------------------------------------
    // å¦‚æœç»“æ„ä½“æŒæœ‰å¼•ç”¨ï¼Œå¿…é¡»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
    // å«ä¹‰ï¼šç»“æ„ä½“å®ä¾‹ä¸èƒ½æ¯”å…¶å¼•ç”¨çš„æ•°æ®æ´»å¾—æ›´ä¹…

    let novel = String::from("åœ¨å¾ˆä¹…å¾ˆä¹…ä»¥å‰. ä¸€ä¸ª...");
    let first_sentence;
    {
        let i = novel.find('.').unwrap_or(novel.len());
        first_sentence = ImportantExcerpt {
            part: &novel[..i],
        };
    }
    println!("æ‘˜å½•: {}", first_sentence.part);

    // ç»“æ„ä½“æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸï¼ˆé€šå¸¸è‡ªåŠ¨æ¨æ–­ï¼‰
    println!("é€šå‘Š: {}", first_sentence.announce_and_return("é‡è¦ï¼"));

    // ----------------------------------------------------------
    // 5. é™æ€ç”Ÿå‘½å‘¨æœŸï¼ˆ'staticï¼‰
    // ----------------------------------------------------------
    // 'static è¡¨ç¤ºå¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆ
    // ã€å¸¸è§ã€‘å­—ç¬¦ä¸²å­—é¢é‡éƒ½æ˜¯ 'static
    // ã€è­¦å‘Šã€‘ä¸è¦éšæ„ä½¿ç”¨ 'static æ¥"è§£å†³"ç”Ÿå‘½å‘¨æœŸé—®é¢˜

    let s: &'static str = "æˆ‘æ˜¯é™æ€ç”Ÿå‘½å‘¨æœŸ";
    println!("{}", s);

    // å­—ç¬¦ä¸²å­—é¢é‡å­˜å‚¨åœ¨ç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œæ‰€ä»¥æ˜¯ 'static
    // const å¸¸é‡å¼•ç”¨ä¹Ÿæ˜¯ 'static

    // ----------------------------------------------------------
    // 6. ç”Ÿå‘½å‘¨æœŸçº¦æŸ
    // ----------------------------------------------------------
    // 'a: 'b è¡¨ç¤º 'a è‡³å°‘å’Œ 'b ä¸€æ ·é•¿

    let s1 = String::from("long");
    let result;
    {
        let s2 = String::from("hi");
        result = longest_with_announcement(&s1, &s2, "æ¯”è¾ƒä¸­...");
        println!("ç»“æœ: {}", result);
    }

    // ----------------------------------------------------------
    // 7. å¸¸è§ç”Ÿå‘½å‘¨æœŸæ¨¡å¼
    // ----------------------------------------------------------
    println!("\n=== å¸¸è§æ¨¡å¼ ===");

    // æ¨¡å¼1: è¿”å›è¾“å…¥çš„å¼•ç”¨
    let data = vec![1, 2, 3, 4, 5];
    let first = first_element(&data);
    println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", first);

    // æ¨¡å¼2: å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°
    let s1 = "hello";
    let s2 = "world";
    let pair = StringPair::new(s1, s2);
    println!("StringPair: {} + {}", pair.first, pair.second);

    // æ¨¡å¼3: ç”Ÿå‘½å‘¨æœŸ + æ³›å‹ + trait bound
    let items = vec![
        String::from("banana"),
        String::from("apple"),
        String::from("cherry"),
    ];
    let longest_item = longest_item(&items);
    println!("æœ€é•¿é¡¹: {}", longest_item);

    println!("\n=== ç”Ÿå‘½å‘¨æœŸç»“æŸ ===");
}

// ----------------------------------------------------------
// éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°
// ----------------------------------------------------------
// 'a è¡¨ç¤ºï¼šè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ = ä¸¤ä¸ªå‚æ•°ä¸­è¾ƒçŸ­çš„é‚£ä¸ª
// ç¼–è¯‘å™¨æ— æ³•è‡ªåŠ¨æ¨æ–­ï¼Œå› ä¸ºæœ‰ä¸¤ä¸ªè¾“å…¥å¼•ç”¨
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// ----------------------------------------------------------
// ç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨æ–­çš„å‡½æ•°ï¼ˆä¸éœ€è¦æ ‡æ³¨ï¼‰
// ----------------------------------------------------------
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &byte) in bytes.iter().enumerate() {
        if byte == b' ' {
            return &s[..i];
        }
    }
    s
}

// ----------------------------------------------------------
// ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
// ----------------------------------------------------------
// å«ä¹‰ï¼šImportantExcerpt å®ä¾‹ä¸èƒ½æ¯” part å¼•ç”¨çš„æ•°æ®æ´»å¾—æ›´ä¹…
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    // è§„åˆ™3 è‡ªåŠ¨æ¨æ–­ï¼šè¿”å›å€¼ç”Ÿå‘½å‘¨æœŸ = &self
    fn announce_and_return(&self, announcement: &str) -> &str {
        println!("è¯·æ³¨æ„: {}", announcement);
        self.part
    }
}

// ----------------------------------------------------------
// ç”Ÿå‘½å‘¨æœŸ + æ³›å‹ + trait bound
// ----------------------------------------------------------
fn longest_with_announcement<'a, T: std::fmt::Display>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str {
    println!("å…¬å‘Š: {}", ann);
    if x.len() > y.len() { x } else { y }
}

// ----------------------------------------------------------
// è¿”å›é›†åˆå…ƒç´ çš„å¼•ç”¨
// ----------------------------------------------------------
fn first_element(v: &Vec<i32>) -> &i32 {
    &v[0]
}

// ----------------------------------------------------------
// å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°
// ----------------------------------------------------------
struct StringPair<'a, 'b> {
    first: &'a str,
    second: &'b str,
}

impl<'a, 'b> StringPair<'a, 'b> {
    fn new(first: &'a str, second: &'b str) -> StringPair<'a, 'b> {
        StringPair { first, second }
    }
}

// ----------------------------------------------------------
// æ³›å‹ + ç”Ÿå‘½å‘¨æœŸ
// ----------------------------------------------------------
fn longest_item<'a>(items: &'a Vec<String>) -> &'a str {
    let mut longest = &items[0] as &str;
    for item in items {
        if item.len() > longest.len() {
            longest = item;
        }
    }
    longest
}
```
