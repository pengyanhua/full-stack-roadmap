# basics.rs

::: info æ–‡ä»¶ä¿¡æ¯
- ğŸ“„ åŸæ–‡ä»¶ï¼š`01_basics.rs`
- ğŸ”¤ è¯­è¨€ï¼šrust
:::

## å®Œæ•´ä»£ç 

```rust
// ============================================================
//                      å‡½æ•°åŸºç¡€
// ============================================================
// Rust ä¸­å‡½æ•°ä½¿ç”¨ fn å…³é”®å­—å®šä¹‰
// ã€å‘½åè§„èŒƒã€‘å‡½æ•°åä½¿ç”¨ snake_caseï¼ˆå¦‚ my_functionï¼‰
// ã€é‡è¦ã€‘Rust ä¸å…³å¿ƒå‡½æ•°å®šä¹‰çš„ä½ç½®ï¼ˆå¯ä»¥å…ˆè°ƒç”¨åå®šä¹‰ï¼‰
// ã€é‡è¦ã€‘å‡½æ•°å‚æ•°å¿…é¡»æ ‡æ³¨ç±»å‹ï¼Œè¿”å›å€¼ç±»å‹ç”¨ -> æ ‡æ³¨

fn main() {
    println!("=== å‡½æ•°åŸºç¡€ ===");

    // ----------------------------------------------------------
    // 1. åŸºæœ¬å‡½æ•°å®šä¹‰ä¸è°ƒç”¨
    // ----------------------------------------------------------
    say_hello();
    greet("Rust");
    greet("ä¸–ç•Œ");

    // ----------------------------------------------------------
    // 2. å¸¦è¿”å›å€¼çš„å‡½æ•°
    // ----------------------------------------------------------
    let result = add(3, 5);
    println!("3 + 5 = {}", result);

    let result2 = add_explicit(10, 20);
    println!("10 + 20 = {}", result2);

    // ----------------------------------------------------------
    // 3. è¡¨è¾¾å¼ vs è¯­å¥
    // ----------------------------------------------------------
    // ã€æ ¸å¿ƒæ¦‚å¿µã€‘Rust æ˜¯åŸºäºè¡¨è¾¾å¼çš„è¯­è¨€
    // - è¯­å¥ï¼ˆStatementï¼‰: æ‰§è¡Œæ“ä½œï¼Œä¸è¿”å›å€¼ï¼Œä»¥åˆ†å·ç»“å°¾
    // - è¡¨è¾¾å¼ï¼ˆExpressionï¼‰: è®¡ç®—å¹¶è¿”å›å€¼ï¼Œæ²¡æœ‰åˆ†å·
    //
    // ã€æ˜“é”™ç‚¹ã€‘å‡½æ•°ä½“æœ€åä¸€è¡Œä¸åŠ åˆ†å· = è¿”å›è¯¥å€¼
    //          å‡½æ•°ä½“æœ€åä¸€è¡ŒåŠ åˆ†å· = è¿”å› ()

    let result = {
        let x = 10;
        let y = 20;
        x + y  // æ²¡æœ‰åˆ†å· â†’ è¿™æ˜¯è¡¨è¾¾å¼ï¼Œä½œä¸ºå—çš„è¿”å›å€¼
    };
    println!("å—è¡¨è¾¾å¼: {}", result); // 30

    // let bad = { let x = 10; x + 20; };  // åŠ äº†åˆ†å·ï¼Œè¿”å› ()

    // ----------------------------------------------------------
    // 4. å¤šè¿”å›å€¼ï¼ˆä½¿ç”¨å…ƒç»„ï¼‰
    // ----------------------------------------------------------
    let (sum, product) = sum_and_product(3, 4);
    println!("å’Œ={}, ç§¯={}", sum, product);

    // ----------------------------------------------------------
    // 5. å‡½æ•°ä½œä¸ºå‚æ•°ï¼ˆé«˜é˜¶å‡½æ•°ï¼‰
    // ----------------------------------------------------------
    let doubled = apply(5, double);
    let squared = apply(5, square);
    println!("apply(5, double) = {}", doubled);
    println!("apply(5, square) = {}", squared);

    // ----------------------------------------------------------
    // 6. æ³›å‹å‡½æ•°
    // ----------------------------------------------------------
    // ä½¿ç”¨ <T> å£°æ˜æ³›å‹å‚æ•°
    // ä½¿ç”¨ trait bound é™åˆ¶æ³›å‹ç±»å‹çš„èƒ½åŠ›

    println!("æœ€å¤§å€¼: {}", max_of(10, 20));
    println!("æœ€å¤§å€¼: {}", max_of(3.14, 2.72));
    println!("æœ€å¤§å€¼: {}", max_of("apple", "banana"));

    // ----------------------------------------------------------
    // 7. æå‰è¿”å›
    // ----------------------------------------------------------
    println!("åˆ†ç±» 0: {}", classify_number(0));
    println!("åˆ†ç±» 42: {}", classify_number(42));
    println!("åˆ†ç±» -5: {}", classify_number(-5));

    // ----------------------------------------------------------
    // 8. å‘æ•£å‡½æ•°ï¼ˆNever Typeï¼‰
    // ----------------------------------------------------------
    // è¿”å›ç±»å‹ä¸º ! çš„å‡½æ•°æ°¸è¿œä¸ä¼šè¿”å›
    // ã€é€‚ç”¨åœºæ™¯ã€‘panic!ã€æ— é™å¾ªç¯ã€è¿›ç¨‹é€€å‡ºç­‰
    // fn forever() -> ! { loop {} }
    // fn crash() -> ! { panic!("boom"); }
    println!("å‘æ•£å‡½æ•°: è¿”å› ! ç±»å‹çš„å‡½æ•°æ°¸è¿œä¸ä¼šæ­£å¸¸è¿”å›");

    // ----------------------------------------------------------
    // 9. æ–¹æ³•è¯­æ³•é¢„è§ˆ
    // ----------------------------------------------------------
    // Rust ä¸­çš„"æ–¹æ³•"æ˜¯åœ¨ impl å—ä¸­å®šä¹‰çš„å‡½æ•°
    // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ selfï¼ˆç±»ä¼¼ Python çš„ self æˆ– Go çš„æ¥æ”¶è€…ï¼‰
    // è¯¦ç»†å†…å®¹è§ç»“æ„ä½“ç« èŠ‚

    let rect = Rectangle { width: 30, height: 50 };
    println!("çŸ©å½¢é¢ç§¯: {}", rect.area());
    println!("çŸ©å½¢æ˜¯å¦ä¸ºæ­£æ–¹å½¢: {}", rect.is_square());

    // å…³è”å‡½æ•°ï¼ˆä¸å¸¦ self çš„å‡½æ•°ï¼Œç±»ä¼¼é™æ€æ–¹æ³•ï¼‰
    let square = Rectangle::new_square(25);
    println!("æ­£æ–¹å½¢: {}x{}", square.width, square.height);

    println!("\n=== å‡½æ•°åŸºç¡€ç»“æŸ ===");
}

// ----------------------------------------------------------
// æ— å‚æ•°æ— è¿”å›å€¼
// ----------------------------------------------------------
fn say_hello() {
    println!("Hello, Rust!");
}

// ----------------------------------------------------------
// å¸¦å‚æ•°çš„å‡½æ•°
// ----------------------------------------------------------
// ã€é‡è¦ã€‘æ¯ä¸ªå‚æ•°éƒ½å¿…é¡»æ ‡æ³¨ç±»å‹
fn greet(name: &str) {
    println!("ä½ å¥½, {}!", name);
}

// ----------------------------------------------------------
// å¸¦è¿”å›å€¼çš„å‡½æ•°
// ----------------------------------------------------------
// æ–¹å¼1: éšå¼è¿”å›ï¼ˆæœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¸åŠ åˆ†å·ï¼‰
// ã€æ¨èã€‘Rust æƒ¯ç”¨å†™æ³•
fn add(a: i32, b: i32) -> i32 {
    a + b  // æ²¡æœ‰åˆ†å·ï¼è¿™å°±æ˜¯è¿”å›å€¼
}

// æ–¹å¼2: æ˜¾å¼è¿”å›ï¼ˆä½¿ç”¨ return å…³é”®å­—ï¼‰
// ã€é€‚ç”¨åœºæ™¯ã€‘æå‰è¿”å›æ—¶ä½¿ç”¨
fn add_explicit(a: i32, b: i32) -> i32 {
    return a + b;  // æœ‰åˆ†å·ï¼Œå› ä¸ºæ˜¯ return è¯­å¥
}

// ----------------------------------------------------------
// è¿”å›å…ƒç»„ï¼ˆå¤šè¿”å›å€¼ï¼‰
// ----------------------------------------------------------
fn sum_and_product(a: i32, b: i32) -> (i32, i32) {
    (a + b, a * b)
}

// ----------------------------------------------------------
// å‡½æ•°ä½œä¸ºå‚æ•°
// ----------------------------------------------------------
// fn(i32) -> i32 æ˜¯å‡½æ•°æŒ‡é’ˆç±»å‹
fn apply(value: i32, func: fn(i32) -> i32) -> i32 {
    func(value)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn square(x: i32) -> i32 {
    x * x
}

// ----------------------------------------------------------
// æ³›å‹å‡½æ•°
// ----------------------------------------------------------
// T: PartialOrd è¡¨ç¤º T å¿…é¡»å®ç°äº† PartialOrd traitï¼ˆå¯æ¯”è¾ƒå¤§å°ï¼‰
fn max_of<T: PartialOrd>(a: T, b: T) -> T {
    if a >= b { a } else { b }
}

// ----------------------------------------------------------
// æå‰è¿”å›
// ----------------------------------------------------------
fn classify_number(n: i32) -> &'static str {
    if n == 0 {
        return "é›¶";  // æå‰è¿”å›
    }
    if n > 0 {
        return "æ­£æ•°";
    }
    "è´Ÿæ•°"  // æœ€åçš„éšå¼è¿”å›
}

// ----------------------------------------------------------
// æ–¹æ³•ï¼ˆåœ¨ impl å—ä¸­å®šä¹‰ï¼‰
// ----------------------------------------------------------
struct Rectangle {
    width: f64,
    height: f64,
}

impl Rectangle {
    // æ–¹æ³•ï¼šç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ &selfï¼ˆå€Ÿç”¨è‡ªèº«ï¼‰
    fn area(&self) -> f64 {
        self.width * self.height
    }

    fn is_square(&self) -> bool {
        (self.width - self.height).abs() < f64::EPSILON
    }

    // å…³è”å‡½æ•°ï¼šæ²¡æœ‰ self å‚æ•°ï¼ˆç±»ä¼¼å…¶ä»–è¯­è¨€çš„é™æ€æ–¹æ³•ï¼‰
    // è°ƒç”¨æ—¶ä½¿ç”¨ :: è¯­æ³•ï¼ˆå¦‚ Rectangle::new_square(5)ï¼‰
    fn new_square(size: f64) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
```
