# 图（Graph）

## 概述

图是由顶点（Vertex）和边（Edge）组成的数据结构，用于表示对象之间的关系。图是最灵活的数据结构之一，可以表示任意复杂的关系网络。

## 图的分类

### 按边的方向

```
无向图（Undirected Graph）          有向图（Directed Graph）
    A ─── B                           A ──→ B
    │     │                           ↑     │
    │     │                           │     ↓
    D ─── C                           D ←── C

边是双向的，A-B 表示                  边是单向的，A→B 表示
A 和 B 互相连接                       只能从 A 到 B
```

### 按边的权重

```
无权图（Unweighted）                 带权图（Weighted）
    A ─── B                           A ─5─ B
    │     │                           │     │
    │     │                           3     2
    D ─── C                           D ─4─ C

所有边权重相同（或为1）               边有不同的权重/代价
```

### 其他分类

```
连通图 vs 非连通图：
┌─────────┐   ┌───┐              ┌───────┐    ┌───┐
│ A ─ B   │   │   │              │ A ─ B │    │ E │
│ │   │   │   │ E │              │ │   │ │    │ │ │
│ D ─ C   │   │   │              │ D ─ C │    │ F │
└─────────┘   └───┘              └───────┘    └───┘
     连通图                           非连通图

有环图 vs 无环图（DAG）：
    A ─→ B                         A ─→ B
    ↑    │                              │
    │    ↓                              ↓
    D ←─ C                         D ─→ C

  有环图（A→B→C→D→A）              DAG（有向无环图）
```

## 图的表示方法

### 1. 邻接矩阵（Adjacency Matrix）

使用二维数组表示，`matrix[i][j]` 表示顶点 i 到顶点 j 的边。

```
图示例：                 邻接矩阵：
    0 ─── 1                  0  1  2  3
    │ ╲   │              0 [ 0  1  1  1 ]
    │   ╲ │              1 [ 1  0  1  0 ]
    3 ─── 2              2 [ 1  1  0  1 ]
                         3 [ 1  0  1  0 ]

带权图邻接矩阵：
    0 ─5─ 1                  0  1  2  3
    │     │              0 [ 0  5  ∞  3 ]
    3     2              1 [ 5  0  2  ∞ ]
    │     │              2 [ ∞  2  0  4 ]
    3 ─4─ 2              3 [ 3  ∞  4  0 ]
```

**优点**：
- 查询边 O(1)
- 适合稠密图
- 实现简单

**缺点**：
- 空间 O(V²)
- 遍历邻居 O(V)
- 稀疏图浪费空间

### 2. 邻接表（Adjacency List）

每个顶点维护一个邻居列表。

```
图示例：                 邻接表：
    0 ─── 1              0: [1, 2, 3]
    │ ╲   │              1: [0, 2]
    │   ╲ │              2: [0, 1, 3]
    3 ─── 2              3: [0, 2]

带权图邻接表：
    0 ─5─ 1              0: [(1,5), (3,3)]
    │     │              1: [(0,5), (2,2)]
    3     2              2: [(1,2), (3,4)]
    │     │              3: [(0,3), (2,4)]
    3 ─4─ 2
```

**优点**：
- 空间 O(V + E)
- 遍历邻居高效
- 适合稀疏图

**缺点**：
- 查询边 O(degree)
- 删除边较慢

### 3. 边列表（Edge List）

直接存储所有边。

```
边列表：[(0,1), (0,2), (0,3), (1,2), (2,3)]

带权边列表：[(0,1,5), (0,3,3), (1,2,2), (2,3,4)]
```

**适用场景**：Kruskal 算法、简单的图处理

## 图的遍历

### 广度优先搜索（BFS）

层层扩展，使用队列实现。

```
       0                    访问顺序：
      /|\
     1 2 3                  第0层: 0
     |   |                  第1层: 1, 2, 3
     4   5                  第2层: 4, 5

BFS: 0 → 1 → 2 → 3 → 4 → 5

过程演示：
队列: [0]          访问: 0, 加入邻居 1,2,3
队列: [1,2,3]      访问: 1, 加入邻居 4
队列: [2,3,4]      访问: 2
队列: [3,4]        访问: 3, 加入邻居 5
队列: [4,5]        访问: 4
队列: [5]          访问: 5
队列: []           结束
```

**应用**：
- 最短路径（无权图）
- 层序遍历
- 连通分量
- 二分图检测

### 深度优先搜索（DFS）

一条路走到底，使用栈或递归实现。

```
       0
      /|\                   DFS（一种可能的顺序）:
     1 2 3                  0 → 1 → 4 → 2 → 3 → 5
     |   |
     4   5

递归过程：
visit(0)
  └─ visit(1)
       └─ visit(4)
            └─ 返回
       └─ 返回
  └─ visit(2)
       └─ 返回
  └─ visit(3)
       └─ visit(5)
            └─ 返回
       └─ 返回
```

**应用**：
- 路径查找
- 环检测
- 拓扑排序
- 强连通分量

### BFS vs DFS 比较

| 特性 | BFS | DFS |
|------|-----|-----|
| 数据结构 | 队列 | 栈/递归 |
| 空间复杂度 | O(宽度) | O(深度) |
| 最短路径 | 是（无权图） | 否 |
| 完整性 | 能找到解 | 能找到解 |
| 适用场景 | 最短路径、层序 | 回溯、拓扑 |

## 最短路径算法

### 1. Dijkstra 算法

适用于**非负权重**的单源最短路径。

```
算法思想：贪心 + 松弛
1. 初始化：起点距离为0，其他为∞
2. 每次选择未访问中距离最小的顶点
3. 更新其邻居的距离（松弛操作）
4. 重复直到所有顶点访问完

示例：从 A 出发
    A ─2─ B
    │     │
    1     3
    │     │
    C ─1─ D

初始: dist = {A:0, B:∞, C:∞, D:∞}

访问A: dist = {A:0, B:2, C:1, D:∞}
       松弛: A→B=2, A→C=1

访问C: dist = {A:0, B:2, C:1, D:2}
       松弛: C→D=1+1=2

访问B: dist = {A:0, B:2, C:1, D:2}
       松弛: B→D=2+3=5 > 2, 不更新

访问D: 完成
最短路径: A→D = 2 (A→C→D)
```

**时间复杂度**：
- 数组实现：O(V²)
- 优先队列：O((V+E)logV)

### 2. Bellman-Ford 算法

支持**负权边**，可检测负环。

```
算法思想：
对所有边进行 V-1 次松弛

伪代码：
for i in range(V-1):
    for each edge (u, v, w):
        if dist[u] + w < dist[v]:
            dist[v] = dist[u] + w

检测负环：
for each edge (u, v, w):
    if dist[u] + w < dist[v]:
        存在负环
```

**时间复杂度**：O(VE)

### 3. Floyd-Warshall 算法

多源最短路径，适用于稠密图。

```
算法思想：动态规划
dist[i][j] = 从 i 到 j 的最短距离
考虑经过顶点 k 是否能缩短路径

转移方程：
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

遍历顺序：
for k in range(V):      # 中间顶点
    for i in range(V):  # 起点
        for j in range(V):  # 终点
            dist[i][j] = min(dist[i][j],
                            dist[i][k] + dist[k][j])
```

**时间复杂度**：O(V³)

### 最短路径算法比较

| 算法 | 适用场景 | 负权边 | 时间复杂度 |
|------|---------|--------|-----------|
| BFS | 无权图 | - | O(V+E) |
| Dijkstra | 非负权图 | 否 | O((V+E)logV) |
| Bellman-Ford | 可有负权 | 是 | O(VE) |
| Floyd-Warshall | 多源最短路径 | 是 | O(V³) |

## 拓扑排序

对有向无环图（DAG）的顶点排序，使得对于每条边 u→v，u 在 v 之前。

```
依赖关系图：
    A ──→ B ──→ D
    │           ↑
    └──→ C ──→──┘

拓扑排序结果（可能有多种）：
A → B → C → D
A → C → B → D
```

### Kahn 算法（BFS）

```
算法步骤：
1. 计算所有顶点的入度
2. 将入度为 0 的顶点加入队列
3. 取出队首顶点，加入结果
4. 将其邻居入度减 1，若变为 0 则入队
5. 重复直到队列为空

示例：
入度: {A:0, B:1, C:1, D:2}
队列: [A]
结果: []

处理A: 队列:[B,C], 结果:[A]
       B入度:0, C入度:0
处理B: 队列:[C,D], 结果:[A,B]
       D入度:1
处理C: 队列:[D], 结果:[A,B,C]
       D入度:0
处理D: 队列:[], 结果:[A,B,C,D]
```

### DFS 实现

```
算法步骤：
1. 对每个未访问顶点执行 DFS
2. DFS 完成后将顶点加入栈
3. 栈的逆序即为拓扑排序

伪代码：
def dfs(node):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs(neighbor)
    stack.append(node)  # 后序位置

result = stack[::-1]  # 逆序
```

## 最小生成树

连接所有顶点的边的子集，使得总权重最小且无环。

```
原图：                      最小生成树：
    A ─4─ B                    A     B
    │╲    │                    │╲
    2  3  1                    2  3  1
    │    ╲│                    │    ╲│
    C ─5─ D                    C     D

MST 边: A-C(2), A-D(3), B-D(1)
总权重: 6
```

### Kruskal 算法

贪心选择最小边，使用并查集避免环。

```
算法步骤：
1. 将所有边按权重排序
2. 依次选择最小边
3. 若不形成环（并查集判断），则加入 MST
4. 重复直到有 V-1 条边

示例：
边排序: B-D(1), A-C(2), A-D(3), A-B(4), C-D(5)

选 B-D(1): 不成环, 加入
选 A-C(2): 不成环, 加入
选 A-D(3): 不成环, 加入
选 A-B(4): 会成环, 跳过
选 C-D(5): 会成环, 跳过

MST: {B-D, A-C, A-D}, 总权重: 6
```

### Prim 算法

从一个顶点开始，贪心扩展。

```
算法步骤：
1. 从任意顶点开始
2. 选择连接已选顶点和未选顶点的最小边
3. 加入该边和新顶点
4. 重复直到所有顶点加入

示例（从 A 开始）：
已选: {A}
边候选: A-B(4), A-C(2), A-D(3)
选 A-C(2), 已选: {A,C}

边候选: A-B(4), A-D(3), C-D(5)
选 A-D(3), 已选: {A,C,D}

边候选: A-B(4), B-D(1)
选 B-D(1), 已选: {A,C,D,B}

MST: {A-C, A-D, B-D}, 总权重: 6
```

### Kruskal vs Prim

| 特性 | Kruskal | Prim |
|------|---------|------|
| 思想 | 按边贪心 | 按顶点扩展 |
| 数据结构 | 并查集 | 优先队列/数组 |
| 时间复杂度 | O(ElogE) | O(ElogV) 或 O(V²) |
| 适用场景 | 稀疏图 | 稠密图 |

## 并查集（Union-Find）

用于处理不相交集合的合并与查询。

```
操作：
1. Find(x): 查找 x 所属集合的代表
2. Union(x, y): 合并 x 和 y 所在的集合

示例：
初始: {0}, {1}, {2}, {3}, {4}

Union(0, 1): {0,1}, {2}, {3}, {4}
Union(2, 3): {0,1}, {2,3}, {4}
Union(0, 2): {0,1,2,3}, {4}

Find(1) = Find(3) = 0  (同一集合)
Find(4) = 4  (不同集合)
```

### 优化技术

```
1. 路径压缩（Path Compression）
   查找时将节点直接连到根

   Before:       After Find(4):
     0              0
     |           / | \ \
     1          1  2  3  4
     |
     2
     |
     3
     |
     4

2. 按秩合并（Union by Rank）
   将较小的树连接到较大的树

   合并前:      合并后(按秩):
   0    3        0
   |    |       /|
   1    4      1 3
   |            |
   2            4
               |
               2
```

## 常见应用场景

| 场景 | 算法/技术 |
|------|----------|
| 社交网络好友关系 | BFS（六度分隔） |
| 导航最短路径 | Dijkstra |
| 任务调度依赖 | 拓扑排序 |
| 网络连接优化 | 最小生成树 |
| 连通性检测 | 并查集 |
| 网页排名 | PageRank |
| 二分图匹配 | 匈牙利算法 |

## 时间复杂度总结

| 操作/算法 | 邻接矩阵 | 邻接表 |
|----------|---------|--------|
| 添加边 | O(1) | O(1) |
| 删除边 | O(1) | O(E) |
| 查询边 | O(1) | O(degree) |
| 遍历邻居 | O(V) | O(degree) |
| BFS/DFS | O(V²) | O(V+E) |
| 存储空间 | O(V²) | O(V+E) |

## 多语言实现对比

### 图的表示

**Python**:
```python
# 邻接表（字典）
graph = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3],
    3: [2]
}

# 或使用 defaultdict
from collections import defaultdict
graph = defaultdict(list)
graph[0].append(1)
```

**Go**:
```go
// 邻接表（map + slice）
graph := map[int][]int{
    0: {1, 2},
    1: {0, 2},
    2: {0, 1, 3},
    3: {2},
}
```

**Java**:
```java
// 邻接表（Map + List）
Map<Integer, List<Integer>> graph = new HashMap<>();
graph.put(0, Arrays.asList(1, 2));
graph.put(1, Arrays.asList(0, 2));

// 或使用数组
List<List<Integer>> graph = new ArrayList<>();
```

**JavaScript/TypeScript**:
```javascript
// 邻接表（Map 或对象）
const graph = new Map([
    [0, [1, 2]],
    [1, [0, 2]],
    [2, [0, 1, 3]],
    [3, [2]]
]);

// 或普通对象
const graph = {
    0: [1, 2],
    1: [0, 2]
};
```

## 学习建议

1. **基础必备**：先掌握 BFS 和 DFS，它们是其他算法的基础
2. **循序渐进**：无权图 → 带权图 → 有向图 → 复杂算法
3. **多画图**：图问题一定要画图分析
4. **模板记忆**：BFS/DFS/Dijkstra 有固定模板
5. **实际应用**：结合实际场景理解算法用途
