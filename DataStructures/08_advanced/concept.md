# 高级数据结构

## 概述

本章介绍几种高级数据结构，它们在特定场景下能提供优异的性能：

| 数据结构 | 主要用途 | 典型操作时间复杂度 |
|---------|---------|------------------|
| Trie（前缀树） | 字符串检索、前缀匹配 | O(m)，m为字符串长度 |
| 线段树 | 区间查询、区间更新 | O(log n) |
| 树状数组 | 前缀和、单点更新 | O(log n) |
| 跳表 | 有序集合操作 | O(log n) 期望 |
| 布隆过滤器 | 快速判断元素存在性 | O(k)，k为哈希函数数量 |

---

## 一、Trie（前缀树 / 字典树）

### 基本概念

Trie 是一种树形结构，用于高效存储和检索字符串集合。

```
存储单词: ["apple", "app", "apply", "bat", "ball"]

                root
               /    \
              a      b
              |      |
              p      a
              |     / \
              p    t   l
             /|\       |
            l e y      l
            |
            e

特点：
- 相同前缀共享节点
- 根节点为空
- 每个节点代表一个字符
- 需要标记单词结尾
```

### 节点结构

```
TrieNode:
┌─────────────────────────────────────┐
│  children: dict/array               │  子节点映射
│  is_end: bool                       │  是否为单词结尾
│  count: int (可选)                  │  以此为前缀的单词数
│  word: str (可选)                   │  存储完整单词
└─────────────────────────────────────┘
```

### 基本操作

```
插入 "apple":
root → a → p → p → l → e(end)

搜索 "app":
root → a → p → p ✓ (is_end = True)

搜索 "ap":
root → a → p ✗ (is_end = False)

前缀搜索 "app":
找到所有以 "app" 为前缀的单词
```

### 时间复杂度

| 操作 | 时间复杂度 |
|------|-----------|
| 插入 | O(m) |
| 搜索 | O(m) |
| 前缀搜索 | O(m + k)，k为结果数 |
| 删除 | O(m) |

其中 m 为字符串长度。

### 应用场景

1. **自动补全**：输入法、搜索建议
2. **拼写检查**：字典匹配
3. **IP 路由表**：最长前缀匹配
4. **字符串统计**：词频统计

### 变体

```
压缩 Trie（Radix Tree）:
将只有一个子节点的路径压缩

普通 Trie:          压缩 Trie:
    r                   r
    |                   |
    o                 "omane"
    |
    m
    |
    a
    |
    n
    |
    e
```

---

## 二、线段树（Segment Tree）

### 基本概念

线段树是一种二叉树，用于高效处理区间查询和区间更新。

```
数组: [1, 3, 5, 7, 9, 11]

              [0,5]=36
             /        \
        [0,2]=9       [3,5]=27
        /    \        /      \
    [0,1]=4  [2]=5  [3,4]=16  [5]=11
    /    \          /     \
  [0]=1  [1]=3   [3]=7   [4]=9

每个节点存储:
- 区间范围 [left, right]
- 区间的聚合值（如：和、最大值、最小值）
```

### 核心操作

#### 1. 构建树

```
从底向上构建：
1. 叶子节点：存储原数组元素
2. 内部节点：合并子节点的值

构建过程（区间和）：
node.value = left_child.value + right_child.value
```

#### 2. 区间查询

```
查询 [1, 4] 的和：

              [0,5]=36
             /        \
        [0,2]=9       [3,5]=27
        /    \        /      \
    [0,1]=4  [2]=5  [3,4]=16  [5]=11

查询过程：
1. [0,5] 与 [1,4] 相交，继续递归
2. [0,2] 与 [1,4] 相交
   - [0,1] 与 [1,4] 部分重叠，继续
     - [1]=3 完全包含，返回 3
   - [2]=5 完全包含，返回 5
3. [3,5] 与 [1,4] 相交
   - [3,4]=16 完全包含，返回 16

结果: 3 + 5 + 16 = 24
```

#### 3. 单点更新

```
更新 index=2 的值为 10：

路径: root → [0,2] → [2]
更新后向上更新所有祖先节点
```

#### 4. 懒惰传播（Lazy Propagation）

用于高效的区间更新。

```
区间 [1,4] 全部加 5：

不是立即更新所有节点，而是：
1. 在覆盖的区间节点打上"懒标记"
2. 查询时再下推标记

lazy[node] = 待下推的增量值

下推操作：
left_child.value += lazy[node] * left_size
right_child.value += lazy[node] * right_size
lazy[left_child] += lazy[node]
lazy[right_child] += lazy[node]
lazy[node] = 0
```

### 时间复杂度

| 操作 | 时间复杂度 |
|------|-----------|
| 构建 | O(n) |
| 单点查询 | O(log n) |
| 区间查询 | O(log n) |
| 单点更新 | O(log n) |
| 区间更新（懒惰传播）| O(log n) |

空间复杂度：O(n)（约 4n 节点）

### 应用场景

1. **区间和/最值查询**
2. **动态 RMQ（区间最值查询）**
3. **计数问题**：区间内满足条件的元素个数
4. **区间修改**：批量更新

---

## 三、树状数组（Binary Indexed Tree / Fenwick Tree）

### 基本概念

树状数组是一种利用二进制特性的数据结构，支持前缀查询和单点更新。

```
数组: [1, 3, 5, 7, 9, 11, 13, 15]
索引:  1  2  3  4  5  6   7   8

树状数组存储（1-indexed）：
BIT[1] = a[1]                    = 1
BIT[2] = a[1] + a[2]             = 4
BIT[3] = a[3]                    = 5
BIT[4] = a[1] + a[2] + a[3] + a[4] = 16
BIT[5] = a[5]                    = 9
BIT[6] = a[5] + a[6]             = 20
BIT[7] = a[7]                    = 13
BIT[8] = a[1] + ... + a[8]       = 64

可视化：
索引:    1    2    3    4    5    6    7    8
        ┌─┐  ┌──┐ ┌─┐ ┌────┐┌─┐ ┌──┐ ┌─┐ ┌────────┐
BIT:    │1│  │ 4│ │5│ │ 16 ││9│ │20│ │13││   64   │
        └─┘  └──┘ └─┘ └────┘└─┘ └──┘ └─┘ └────────┘

规律：BIT[i] 管理的元素个数 = lowbit(i)
lowbit(i) = i & (-i)  // 最低位的1
```

### 核心操作

#### lowbit 函数

```
lowbit(i) = i & (-i)

示例：
i = 6  = 0110
-i     = 1010
i & -i = 0010 = 2

lowbit(6) = 2
表示 BIT[6] 管理 2 个元素
```

#### 前缀和查询

```
query(i): 计算 a[1] + a[2] + ... + a[i]

def query(i):
    sum = 0
    while i > 0:
        sum += BIT[i]
        i -= lowbit(i)  # 移除最低位的1
    return sum

示例：query(7)
i=7: sum += BIT[7], i = 7 - 1 = 6
i=6: sum += BIT[6], i = 6 - 2 = 4
i=4: sum += BIT[4], i = 4 - 4 = 0
结果: BIT[7] + BIT[6] + BIT[4] = 13 + 20 + 16 = 49
```

#### 单点更新

```
update(i, delta): a[i] += delta

def update(i, delta):
    while i <= n:
        BIT[i] += delta
        i += lowbit(i)  # 加上最低位的1

示例：update(3, 2)  // a[3] += 2
i=3: BIT[3] += 2, i = 3 + 1 = 4
i=4: BIT[4] += 2, i = 4 + 4 = 8
i=8: BIT[8] += 2, i = 8 + 8 = 16 > n
```

### 区间查询

```
区间 [l, r] 的和 = query(r) - query(l-1)
```

### 时间复杂度

| 操作 | 时间复杂度 |
|------|-----------|
| 构建 | O(n log n) 或 O(n) |
| 前缀查询 | O(log n) |
| 单点更新 | O(log n) |
| 区间查询 | O(log n) |

空间复杂度：O(n)

### 树状数组 vs 线段树

| 特性 | 树状数组 | 线段树 |
|------|---------|--------|
| 实现复杂度 | 简单 | 较复杂 |
| 空间 | n | 4n |
| 区间更新 | 需要差分数组 | 懒惰传播 |
| 功能 | 有限 | 更通用 |
| 常数因子 | 小 | 较大 |

---

## 四、跳表（Skip List）

### 基本概念

跳表是一种基于链表的数据结构，通过多层索引实现快速查找。

```
Level 3:  1 ─────────────────────────→ 9 ─────→ NULL
          │                            │
Level 2:  1 ─────────→ 5 ─────────────→ 9 ─────→ NULL
          │            │               │
Level 1:  1 ───→ 3 ───→ 5 ───→ 7 ─────→ 9 ─────→ NULL
          │      │      │      │       │
Level 0:  1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → NULL

特点：
- Level 0 包含所有元素
- 每上一层约有 1/2 的节点
- 类似二分查找的效果
```

### 节点结构

```
SkipListNode:
┌────────────────────────────────┐
│  value: T                      │  节点值
│  forward: List[Node]           │  各层的下一个节点
└────────────────────────────────┘

forward[i] = 第 i 层的下一个节点
```

### 查找过程

```
查找 7:

Level 3:  1 ─────────────────────────→ 9 (7 < 9, 下降)
          ↓
Level 2:  1 ─────────→ 5 ─────────────→ 9 (7 > 5, 前进)
                       ↓
Level 2:               5 ─────────────→ 9 (7 < 9, 下降)
                       ↓
Level 1:               5 ───→ 7 (找到!)

时间复杂度: O(log n) 期望
```

### 插入过程

```
插入 6:

1. 找到各层的插入位置
2. 随机决定新节点的高度（抛硬币）
3. 在各层插入节点

插入前:
Level 1:  1 ───→ 5 ───→ 7 ───→ 9
Level 0:  1 → 3 → 5 → 7 → 9

假设新节点高度为 2:
Level 1:  1 ───→ 5 ───→ 6 ───→ 7 ───→ 9
Level 0:  1 → 3 → 5 → 6 → 7 → 9
```

### 层数确定

```
概率方法：
p = 0.5（通常）

def random_level():
    level = 1
    while random() < p and level < MAX_LEVEL:
        level += 1
    return level

期望层数：1 / (1 - p) = 2（当 p = 0.5）
```

### 时间复杂度

| 操作 | 平均 | 最坏 |
|------|-----|-----|
| 查找 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |

空间复杂度：O(n) 期望

### 跳表 vs 平衡树

| 特性 | 跳表 | 平衡树（如红黑树） |
|------|-----|------------------|
| 实现复杂度 | 简单 | 复杂 |
| 范围查询 | 高效 | 需要中序遍历 |
| 并发支持 | 容易 | 困难 |
| 缓存友好性 | 较好 | 较差 |
| 稳定性 | 概率保证 | 确定性保证 |

### 应用场景

- **Redis 有序集合**（ZSet）
- **LevelDB / RocksDB**
- **需要范围查询的场景**

---

## 五、布隆过滤器（Bloom Filter）

### 基本概念

布隆过滤器是一种概率型数据结构，用于快速判断元素是否**可能存在**于集合中。

```
特点：
- 可能存在误判（假阳性）
- 不会漏判（无假阴性）
- 不支持删除
- 空间效率极高

判断结果：
- "可能存在" → 元素可能在集合中，也可能不在
- "一定不存在" → 元素一定不在集合中
```

### 工作原理

```
组成：
1. 位数组 bit[0...m-1]，初始全为 0
2. k 个独立的哈希函数 h1, h2, ..., hk

插入元素 x:
for i in 1..k:
    bit[hi(x) % m] = 1

查询元素 x:
for i in 1..k:
    if bit[hi(x) % m] == 0:
        return "一定不存在"
return "可能存在"
```

### 图示

```
插入 "apple" 和 "banana":

位数组 (m=16):
索引:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
      ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬──┬──┬──┬──┬──┬──┐
      │0│0│1│0│1│0│0│1│0│1│ 0│ 1│ 0│ 0│ 1│ 0│
      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴──┴──┴──┴──┴──┴──┘
            ↑   ↑     ↑   ↑    ↑          ↑
           h1  h2    h1  h2   h1         h2
          apple     apple    banana     banana

查询 "orange":
h1("orange") = 3 → bit[3] = 0 → 一定不存在 ✓

查询 "cherry":
h1("cherry") = 2 → bit[2] = 1
h2("cherry") = 7 → bit[7] = 1
→ 可能存在（但实际不存在，这是误判）
```

### 误判率计算

```
参数：
- m: 位数组大小
- n: 预期元素数量
- k: 哈希函数数量

误判率（假阳性率）:
p ≈ (1 - e^(-kn/m))^k

最优 k 值:
k = (m/n) * ln(2) ≈ 0.693 * (m/n)

给定误判率 p，所需位数组大小:
m = -n * ln(p) / (ln(2))^2
```

### 参数选择示例

```
预期 100 万元素，误判率 1%:

m = -1000000 * ln(0.01) / (ln(2))^2
  ≈ 9,585,059 bits ≈ 1.2 MB

k = 0.693 * (9585059 / 1000000)
  ≈ 6.64 → 取 7

对比直接存储:
假设每个元素 100 字节
直接存储: 100 MB
布隆过滤器: 1.2 MB（节省 ~98%）
```

### 时间复杂度

| 操作 | 时间复杂度 |
|------|-----------|
| 插入 | O(k) |
| 查询 | O(k) |
| 空间 | O(m) |

k 通常很小（< 20），所以可视为 O(1)。

### 变体

```
1. 计数布隆过滤器（Counting Bloom Filter）
   - 用计数器替代位
   - 支持删除操作
   - 空间增加 3-4 倍

2. 布谷鸟过滤器（Cuckoo Filter）
   - 支持删除
   - 更低的误判率
   - 更好的空间效率
```

### 应用场景

1. **数据库查询优化**：判断数据是否存在再查库
2. **缓存穿透防护**：过滤不存在的 key
3. **URL 去重**：爬虫中快速判断 URL 是否已访问
4. **垃圾邮件过滤**
5. **分布式系统**：减少不必要的网络请求

---

## 六、其他高级数据结构（简介）

### 1. B 树 / B+ 树

```
用于数据库和文件系统的多路搜索树

B+ 树特点：
- 所有数据存在叶子节点
- 叶子节点形成链表
- 非叶子节点只存索引

        [30 | 60]
       /    |    \
   [10|20] [40|50] [70|80]
   ↓  ↓    ↓  ↓    ↓  ↓
  叶子节点链表 →→→→→→→
```

### 2. 红黑树

```
自平衡二叉搜索树

性质：
1. 节点是红色或黑色
2. 根是黑色
3. 叶子（NIL）是黑色
4. 红节点的子节点必须是黑色
5. 任一节点到叶子的路径包含相同数量的黑节点

保证最长路径不超过最短路径的两倍
```

### 3. KD 树

```
用于多维空间搜索

2D 示例：
       (7,2)
      /     \
   (5,4)   (9,6)
   /   \      \
(2,3) (4,7)  (8,1)

应用：最近邻搜索、范围搜索
```

### 4. 后缀树 / 后缀数组

```
用于字符串匹配

字符串 "banana$" 的后缀:
banana$
anana$
nana$
ana$
na$
a$
$

应用：子串搜索、最长公共子串
```

---

## 数据结构选择指南

| 需求 | 推荐数据结构 |
|------|-------------|
| 前缀匹配/自动补全 | Trie |
| 区间查询/更新 | 线段树 |
| 前缀和 + 单点更新 | 树状数组 |
| 有序集合 + 范围查询 | 跳表 |
| 快速判断存在性 | 布隆过滤器 |
| 磁盘存储索引 | B+ 树 |
| 内存有序映射 | 红黑树 |
| 多维空间搜索 | KD 树 |
| 字符串模式匹配 | 后缀数组/AC 自动机 |

## 学习建议

1. **先掌握基础**：确保链表、树、图等基础扎实
2. **理解应用场景**：每种数据结构有其适用场景
3. **动手实现**：只看不写很难真正理解
4. **分析复杂度**：不仅要会用，还要知道为什么
5. **结合实际**：找实际项目或 LeetCode 题目练习
