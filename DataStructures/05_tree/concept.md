# 树 (Tree)

## 概念

树是一种**非线性**的层级数据结构，由节点和边组成。

```
树的结构：

                    1          ← 根节点 (root)
                  / | \
                 2  3  4       ← 子节点
                /|     |\
               5 6     7 8     ← 叶节点 (leaf)

术语：
- 根节点 (root): 最顶层节点，无父节点
- 叶节点 (leaf): 无子节点的节点
- 内部节点: 有子节点的非叶节点
- 父节点/子节点: 直接相连的上下级关系
- 兄弟节点: 同一父节点的子节点
- 深度 (depth): 从根到该节点的边数
- 高度 (height): 从该节点到最远叶节点的边数
- 层级 (level): 深度 + 1
```

## 二叉树 (Binary Tree)

### 定义

每个节点最多有两个子节点（左子节点和右子节点）。

```
二叉树结构：

       1
      / \
     2   3
    / \   \
   4   5   6

节点结构：
┌─────────────────┐
│ left │ val │ right │
└─────────────────┘
```

### 二叉树类型

```
1. 满二叉树 (Full Binary Tree)
   每个节点有 0 或 2 个子节点

       1
      / \
     2   3
    / \
   4   5

2. 完全二叉树 (Complete Binary Tree)
   除最后一层外全满，最后一层从左到右填充

       1
      / \
     2   3
    / \  /
   4  5 6

3. 完美二叉树 (Perfect Binary Tree)
   所有内部节点都有两个子节点，所有叶节点在同一层

       1
      / \
     2   3
    /\   /\
   4 5  6 7

4. 平衡二叉树 (Balanced Binary Tree)
   任意节点的左右子树高度差不超过 1

5. 退化二叉树 (Degenerate Tree)
   每个节点只有一个子节点，退化为链表

   1
    \
     2
      \
       3
```

### 二叉树性质

```
设节点数为 n，高度为 h：

1. 第 i 层最多有 2^(i-1) 个节点
2. 高度为 h 的二叉树最多有 2^h - 1 个节点
3. n 个节点的完全二叉树高度为 ⌊log₂n⌋ + 1
4. 叶节点数 = 度为2的节点数 + 1
5. 数组存储时（索引从0开始）：
   - 父节点索引: (i-1) / 2
   - 左子节点索引: 2*i + 1
   - 右子节点索引: 2*i + 2
```

## 二叉树遍历

```
示例树：
       1
      / \
     2   3
    / \
   4   5

前序 (Pre-order):  根 → 左 → 右  = [1, 2, 4, 5, 3]
中序 (In-order):   左 → 根 → 右  = [4, 2, 5, 1, 3]
后序 (Post-order): 左 → 右 → 根  = [4, 5, 2, 3, 1]
层序 (Level-order): 逐层遍历    = [1, 2, 3, 4, 5]
```

### 遍历图解

```
前序遍历：
       1 ─────────────────┐
      / \                 ↓
     2   3 ────────────→ [1, 2, 4, 5, 3]
    / \
   4   5
   第一个访问根节点

中序遍历：
       1
      / \
     2   3 ────────────→ [4, 2, 5, 1, 3]
    / \
   4   5
   左子树完成后访问根

后序遍历：
       1
      / \
     2   3 ────────────→ [4, 5, 2, 3, 1]
    / \
   4   5
   最后访问根节点
```

## 二叉搜索树 (BST)

### 定义

```
特性：
- 左子树所有节点 < 根节点
- 右子树所有节点 > 根节点
- 左右子树也是 BST

       8
      / \
     3   10
    /\     \
   1  6    14
     /\    /
    4  7  13

中序遍历得到有序序列: [1, 3, 4, 6, 7, 8, 10, 13, 14]
```

### 时间复杂度

| 操作 | 平均 | 最坏（退化） |
|------|------|-------------|
| 查找 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |

### BST 删除操作

```
情况1: 叶节点
  直接删除

情况2: 只有一个子节点
  用子节点替换

情况3: 有两个子节点
  用后继（右子树最小值）或前驱（左子树最大值）替换

删除节点 3:
       8                    8
      / \                  / \
     3   10      →        4   10
    /\     \             /\     \
   1  6    14           1  6    14
     /\                   \
    4  7                   7

用后继节点 4 替换 3
```

## 平衡二叉树

### AVL 树

```
特性：任意节点左右子树高度差不超过 1

平衡因子 = 左子树高度 - 右子树高度
平衡因子 ∈ {-1, 0, 1}

失衡时通过旋转恢复平衡：

LL 型（左左）→ 右旋：
    3          2
   /          / \
  2    →     1   3
 /
1

RR 型（右右）→ 左旋：
1              2
 \            / \
  2    →     1   3
   \
    3

LR 型（左右）→ 先左旋后右旋：
  3        3        2
 /        /        / \
1   →    2   →    1   3
 \      /
  2    1

RL 型（右左）→ 先右旋后左旋：
1        1          2
 \        \        / \
  3  →     2  →   1   3
 /          \
2            3
```

### 红黑树

```
特性：
1. 节点是红色或黑色
2. 根节点是黑色
3. 叶节点（NIL）是黑色
4. 红色节点的子节点都是黑色
5. 从任意节点到其所有后代叶节点的路径上，黑色节点数量相同

优点：插入删除效率高于 AVL
应用：Java TreeMap、C++ std::map
```

## 其他树结构

### B 树 / B+ 树

```
B+ 树特点：
- 多路平衡搜索树
- 所有数据在叶节点
- 叶节点形成链表

应用：数据库索引、文件系统
```

### 字典树 (Trie)

```
前缀树结构：

存储 ["apple", "app", "banana"]

         (root)
         /    \
        a      b
        |      |
        p      a
        |      |
        p(*)   n
        |      |
        l      a
        |      |
        e(*)   n
               |
               a(*)

(*) 表示单词结尾

应用：自动补全、拼写检查、IP 路由
```

### 线段树

```
用于区间查询和更新

数组: [1, 3, 5, 7, 9, 11]

            [36]           区间和
          /      \
       [9]       [27]
       / \       /  \
     [4] [5]  [16] [11]
     /\        /\
   [1][3]   [7][9]

区间查询: O(log n)
点更新: O(log n)
```

## 时间复杂度对比

| 树类型 | 查找 | 插入 | 删除 |
|--------|------|------|------|
| 二叉树 | O(n) | O(n) | O(n) |
| BST（平均）| O(log n) | O(log n) | O(log n) |
| BST（最坏）| O(n) | O(n) | O(n) |
| AVL | O(log n) | O(log n) | O(log n) |
| 红黑树 | O(log n) | O(log n) | O(log n) |
| B 树 | O(log n) | O(log n) | O(log n) |

## 相关算法题

| 难度 | 题目 | 核心技巧 |
|------|------|----------|
| 简单 | 二叉树的最大深度 | DFS/BFS |
| 简单 | 翻转二叉树 | 递归 |
| 简单 | 对称二叉树 | 递归/迭代 |
| 简单 | 二叉树的直径 | DFS |
| 中等 | 二叉树的层序遍历 | BFS |
| 中等 | 验证二叉搜索树 | 中序遍历 |
| 中等 | 二叉树的最近公共祖先 | 递归 |
| 中等 | 从前序与中序遍历构造二叉树 | 分治 |
| 困难 | 二叉树的序列化与反序列化 | BFS/DFS |
| 困难 | 二叉树中的最大路径和 | DFS |

## 多语言节点定义

```python
# Python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

```go
// Go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```

```java
// Java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}
```
