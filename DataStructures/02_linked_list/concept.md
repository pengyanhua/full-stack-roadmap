# 链表 (Linked List)

## 概念

链表是一种**线性数据结构**，元素通过**指针/引用**连接，不要求连续存储。

```
单向链表：
┌───────────┐    ┌───────────┐    ┌───────────┐    ┌───────────┐
│  1  │  ●──┼───>│  2  │  ●──┼───>│  3  │  ●──┼───>│  4  │ None│
└───────────┘    └───────────┘    └───────────┘    └───────────┘
    head                                               tail

双向链表：
     ┌───────────────┐    ┌───────────────┐    ┌───────────────┐
None │ ● │  1  │  ●──┼───>│ ● │  2  │  ●──┼───>│ ● │  3  │ None│
     └───┼───────────┘    └───┼───────────┘    └───────────────┘
         │    ↑               │    ↑
         └────┘               └────┘
```

## 链表 vs 数组

| 特性 | 数组 | 链表 |
|------|------|------|
| 内存分配 | 连续 | 分散 |
| 访问方式 | 随机访问 O(1) | 顺序访问 O(n) |
| 插入/删除（已知位置） | O(n) | O(1) |
| 插入/删除（需查找） | O(n) | O(n) |
| 内存效率 | 高（无指针开销） | 低（需存储指针） |
| 缓存友好 | 是（局部性好） | 否（分散存储） |
| 大小调整 | 需扩容/缩容 | 动态增减 |

## 链表类型

### 1. 单向链表 (Singly Linked List)

```
节点结构:
┌─────────────┐
│ data │ next │
└─────────────┘

每个节点只有指向下一个节点的指针
```

### 2. 双向链表 (Doubly Linked List)

```
节点结构:
┌──────────────────┐
│ prev │ data │ next │
└──────────────────┘

每个节点有前驱和后继指针
优点：可双向遍历，删除效率更高
缺点：空间开销更大
```

### 3. 循环链表 (Circular Linked List)

```
单向循环：
┌───┐    ┌───┐    ┌───┐
│ 1 │───>│ 2 │───>│ 3 │──┐
└───┘    └───┘    └───┘  │
  ↑                      │
  └──────────────────────┘

双向循环：
     ┌────────────────────────────────┐
     ↓                                │
┌─────────┐    ┌─────────┐    ┌─────────┐
│ 1 │  ●──┼───>│ 2 │  ●──┼───>│ 3 │  ●──┘
└─────────┘    └─────────┘    └─────────┘
  ↑    │         ↑    │         ↑    │
  └────┘         └────┘         └────┘
```

## 时间复杂度

### 单向链表

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 头部访问 | O(1) | 直接访问 head |
| 尾部访问 | O(n) / O(1)* | *如果维护 tail 指针 |
| 按索引访问 | O(n) | 需要遍历 |
| 头部插入 | O(1) | 直接操作 |
| 尾部插入 | O(n) / O(1)* | *如果维护 tail 指针 |
| 中间插入（已知位置） | O(1) | 修改指针 |
| 中间插入（需查找） | O(n) | 先遍历再插入 |
| 头部删除 | O(1) | 直接操作 |
| 尾部删除 | O(n) | 需找到倒数第二个 |
| 中间删除（已知位置） | O(1) | 修改指针 |
| 搜索 | O(n) | 需要遍历 |

### 双向链表

| 操作 | 时间复杂度 |
|------|-----------|
| 头部/尾部访问 | O(1) |
| 头部/尾部插入 | O(1) |
| 头部/尾部删除 | O(1) |
| 已知节点删除 | O(1) |

## 核心操作图解

### 插入操作

```
在节点 B 后插入 X:

Before:
A ──> B ──> C

Step 1: X.next = B.next (X 指向 C)
A ──> B ──> C
      X ───↗

Step 2: B.next = X (B 指向 X)
A ──> B ──> X ──> C

After:
A ──> B ──> X ──> C
```

### 删除操作

```
删除节点 B:

Before:
A ──> B ──> C

需要知道 B 的前驱 A:
A.next = B.next

After:
A ──> C
      B (断开连接)
```

### 反转链表

```
原链表:
1 ──> 2 ──> 3 ──> None

使用三个指针: prev, curr, next

Step 1:
prev=None, curr=1
    None <── 1    2 ──> 3 ──> None
            curr

Step 2:
prev=1, curr=2
    None <── 1 <── 2    3 ──> None
                  curr

Step 3:
prev=2, curr=3
    None <── 1 <── 2 <── 3    None
                        curr

Result:
None <── 1 <── 2 <── 3
                    head
```

## 常见技巧

### 1. 哨兵节点 (Dummy Node)

```python
# 简化边界条件处理
dummy = ListNode(0)
dummy.next = head

# 操作完成后返回
return dummy.next
```

### 2. 快慢指针

```
找中点：快指针走两步，慢指针走一步
1 ──> 2 ──> 3 ──> 4 ──> 5
      ↑               ↑
     slow           fast

检测环：快慢指针最终会相遇
1 ──> 2 ──> 3 ──> 4
            ↑     │
            └─────┘
```

### 3. 递归思维

```python
# 链表天然适合递归
def reverse(head):
    if not head or not head.next:
        return head
    new_head = reverse(head.next)
    head.next.next = head
    head.next = None
    return new_head
```

## 适用场景

**适合使用链表：**
- ✅ 频繁在头部/中间插入删除
- ✅ 不需要随机访问
- ✅ 事先不知道数据规模
- ✅ 实现栈、队列、LRU 缓存

**不适合使用链表：**
- ❌ 需要频繁随机访问
- ❌ 内存空间紧张
- ❌ 需要二分查找

## 相关算法题

| 难度 | 题目 | 核心技巧 |
|------|------|----------|
| 简单 | 反转链表 | 三指针迭代/递归 |
| 简单 | 合并两个有序链表 | 归并思想 |
| 简单 | 链表的中间节点 | 快慢指针 |
| 简单 | 相交链表 | 双指针同步 |
| 简单 | 回文链表 | 快慢指针 + 反转 |
| 中等 | 删除链表的倒数第N个节点 | 快慢指针 |
| 中等 | 环形链表 II | 快慢指针 + 数学 |
| 中等 | 两数相加 | 模拟加法 |
| 中等 | 排序链表 | 归并排序 |
| 困难 | 合并K个升序链表 | 分治/优先队列 |
| 困难 | K个一组翻转链表 | 分组处理 |

## 多语言对照

```python
# Python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

```go
// Go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

```java
// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}
```

```cpp
// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};
```
