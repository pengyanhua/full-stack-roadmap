# 哈希表 (Hash Table)

## 概念

哈希表是一种基于**键值对 (Key-Value)** 的数据结构，通过**哈希函数**将键映射到数组索引，实现近乎 O(1) 的查找。

```
哈希表结构：

    key    hash(key)   index      value
    ───────────────────────────────────────
    "apple"  ──────►    2    ───► "苹果"
    "banana" ──────►    5    ───► "香蕉"
    "cherry" ──────►    1    ───► "樱桃"

存储数组：
    ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┐
    │      │cherry│apple │      │      │banana│      │
    └──────┴──────┴──────┴──────┴──────┴──────┴──────┘
      [0]    [1]    [2]    [3]    [4]    [5]    [6]
```

## 核心组件

### 1. 哈希函数 (Hash Function)

```
作用：将任意大小的键映射到固定范围的整数

好的哈希函数特点：
- 确定性：相同输入产生相同输出
- 均匀分布：减少冲突
- 高效计算：时间复杂度低

常见哈希函数：
1. 取模法：hash(key) = key % table_size
2. 乘法哈希：hash(key) = floor(table_size * (key * A mod 1))
3. 多项式哈希：用于字符串
```

### 2. 字符串哈希示例

```python
def string_hash(s: str, table_size: int) -> int:
    """多项式哈希"""
    hash_val = 0
    p = 31  # 质数
    for char in s:
        hash_val = (hash_val * p + ord(char)) % table_size
    return hash_val
```

## 冲突解决

当两个键映射到相同索引时发生**哈希冲突**。

### 1. 链地址法 (Separate Chaining)

```
每个槽位存储一个链表：

     0      1      2      3      4
   ┌────┬────┬────┬────┬────┐
   │ ●  │null│ ●  │null│ ●  │
   └─┬──┴────┴─┬──┴────┴─┬──┘
     ↓         ↓         ↓
   ┌────┐   ┌────┐   ┌────┐
   │ A  │   │ B  │   │ D  │
   └─┬──┘   └─┬──┘   └────┘
     ↓        ↓
   ┌────┐   ┌────┐
   │ E  │   │ C  │
   └────┘   └────┘

优点：实现简单，删除方便
缺点：需要额外空间存储指针
```

### 2. 开放地址法 (Open Addressing)

```
冲突时在数组内寻找下一个空槽位：

线性探测：
  index = (hash(key) + i) % table_size
  i = 1, 2, 3, ...

插入 E（hash=2，位置2被占）：
┌────┬────┬────┬────┬────┬────┐
│ A  │    │ B  │    │    │    │  初始
└────┴────┴────┴────┴────┴────┘
  [0]  [1]  [2]  [3]  [4]  [5]

┌────┬────┬────┬────┬────┬────┐
│ A  │    │ B  │ E  │    │    │  E 放到 [3]
└────┴────┴────┴────┴────┴────┘

二次探测：
  index = (hash(key) + i²) % table_size
  减少聚集问题

双重哈希：
  index = (hash1(key) + i * hash2(key)) % table_size
  使用第二个哈希函数确定步长
```

### 比较

| 方法 | 优点 | 缺点 |
|------|------|------|
| 链地址法 | 删除简单、装载因子可超过1 | 需要额外指针空间 |
| 开放地址法 | 空间连续、缓存友好 | 删除复杂、聚集问题 |

## 时间复杂度

| 操作 | 平均 | 最坏 |
|------|------|------|
| 插入 | O(1) | O(n) |
| 查找 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

最坏情况发生在所有键都冲突时（退化为链表）。

## 装载因子 (Load Factor)

```
装载因子 α = 元素数量 / 桶数量

α 太高 → 冲突增多，性能下降
α 太低 → 空间浪费

常见阈值：
- Java HashMap: 0.75
- Python dict: 0.67
- Go map: 6.5 (每个桶平均6.5个元素)

扩容策略：
当 α > 阈值时，将桶数量翻倍并重新哈希
```

## 动态扩容

```
扩容过程（Rehashing）：

Before (size=4):
┌─────┬─────┬─────┬─────┐
│  A  │ B,E │  C  │  D  │
└─────┴─────┴─────┴─────┘

After (size=8):
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│  A  │     │  B  │  C  │  D  │     │  E  │     │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴

所有元素需要重新计算哈希值
均摊时间复杂度仍为 O(1)
```

## 各语言实现

| 语言 | 类型 | 冲突解决 | 特点 |
|------|------|----------|------|
| Python | dict | 开放地址法 | 3.7+ 保持插入顺序 |
| Java | HashMap | 链地址法 | 链表超过8转红黑树 |
| Go | map | 链地址法 | 不保证顺序 |
| C++ | unordered_map | 链地址法 | STL 标准 |
| JavaScript | Object/Map | V8优化实现 | Map 保持顺序 |

## 哈希表变体

### 1. 有序哈希表 (LinkedHashMap)

```
维护插入顺序的双向链表：

HashMap + 双向链表

插入: a → b → c → d
访问顺序: a → b → c → d (保持插入顺序)

应用: LRU 缓存
```

### 2. 布隆过滤器 (Bloom Filter)

```
概率型数据结构，判断元素是否可能存在

特点:
- 可能存在 → 可能存在也可能不存在（假阳性）
- 不存在 → 一定不存在（无假阴性）
- 空间效率极高

应用: 垃圾邮件过滤、缓存穿透防护
```

### 3. 一致性哈希 (Consistent Hashing)

```
用于分布式系统的负载均衡

传统哈希问题：
  server = hash(key) % n
  增减服务器时，大量数据需要迁移

一致性哈希：
  将服务器和数据都映射到环上
  数据顺时针找到第一个服务器
  增减服务器只影响相邻区间

应用: 分布式缓存、负载均衡
```

## 适用场景

**适合使用哈希表：**
- ✅ 需要快速查找、插入、删除
- ✅ 键值对存储
- ✅ 去重
- ✅ 计数
- ✅ 缓存

**不适合使用哈希表：**
- ❌ 需要有序遍历
- ❌ 范围查询
- ❌ 内存敏感场景

## 相关算法题

| 难度 | 题目 | 核心技巧 |
|------|------|----------|
| 简单 | 两数之和 | 哈希表存储补数 |
| 简单 | 有效的字母异位词 | 字符计数 |
| 简单 | 存在重复元素 | 哈希集合去重 |
| 中等 | 字母异位词分组 | 排序后作为键 |
| 中等 | 最长连续序列 | 哈希集合 + 并查集思想 |
| 中等 | LRU 缓存 | 哈希表 + 双向链表 |
| 困难 | LFU 缓存 | 多级哈希表 |

## 多语言对照

```python
# Python
d = {}
d = dict()
d['key'] = 'value'    # 插入/更新
val = d.get('key')    # 查找（不存在返回 None）
val = d['key']        # 查找（不存在抛异常）
del d['key']          # 删除
'key' in d            # 检查存在
```

```go
// Go
m := make(map[string]string)
m["key"] = "value"           // 插入/更新
val, ok := m["key"]          // 查找
delete(m, "key")             // 删除
_, exists := m["key"]        // 检查存在
```

```java
// Java
Map<String, String> map = new HashMap<>();
map.put("key", "value");     // 插入/更新
String val = map.get("key"); // 查找
map.remove("key");           // 删除
map.containsKey("key");      // 检查存在
```

```javascript
// JavaScript
const map = new Map();
map.set('key', 'value');     // 插入/更新
map.get('key');              // 查找
map.delete('key');           // 删除
map.has('key');              // 检查存在
```
