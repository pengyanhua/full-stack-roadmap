// ============================================================
//                      函数基础
// ============================================================
// Rust 中函数使用 fn 关键字定义
// 【命名规范】函数名使用 snake_case（如 my_function）
// 【重要】Rust 不关心函数定义的位置（可以先调用后定义）
// 【重要】函数参数必须标注类型，返回值类型用 -> 标注

fn main() {
    println!("=== 函数基础 ===");

    // ----------------------------------------------------------
    // 1. 基本函数定义与调用
    // ----------------------------------------------------------
    say_hello();
    greet("Rust");
    greet("世界");

    // ----------------------------------------------------------
    // 2. 带返回值的函数
    // ----------------------------------------------------------
    let result = add(3, 5);
    println!("3 + 5 = {}", result);

    let result2 = add_explicit(10, 20);
    println!("10 + 20 = {}", result2);

    // ----------------------------------------------------------
    // 3. 表达式 vs 语句
    // ----------------------------------------------------------
    // 【核心概念】Rust 是基于表达式的语言
    // - 语句（Statement）: 执行操作，不返回值，以分号结尾
    // - 表达式（Expression）: 计算并返回值，没有分号
    //
    // 【易错点】函数体最后一行不加分号 = 返回该值
    //          函数体最后一行加分号 = 返回 ()

    let result = {
        let x = 10;
        let y = 20;
        x + y  // 没有分号 → 这是表达式，作为块的返回值
    };
    println!("块表达式: {}", result); // 30

    // let bad = { let x = 10; x + 20; };  // 加了分号，返回 ()

    // ----------------------------------------------------------
    // 4. 多返回值（使用元组）
    // ----------------------------------------------------------
    let (sum, product) = sum_and_product(3, 4);
    println!("和={}, 积={}", sum, product);

    // ----------------------------------------------------------
    // 5. 函数作为参数（高阶函数）
    // ----------------------------------------------------------
    let doubled = apply(5, double);
    let squared = apply(5, square);
    println!("apply(5, double) = {}", doubled);
    println!("apply(5, square) = {}", squared);

    // ----------------------------------------------------------
    // 6. 泛型函数
    // ----------------------------------------------------------
    // 使用 <T> 声明泛型参数
    // 使用 trait bound 限制泛型类型的能力

    println!("最大值: {}", max_of(10, 20));
    println!("最大值: {}", max_of(3.14, 2.72));
    println!("最大值: {}", max_of("apple", "banana"));

    // ----------------------------------------------------------
    // 7. 提前返回
    // ----------------------------------------------------------
    println!("分类 0: {}", classify_number(0));
    println!("分类 42: {}", classify_number(42));
    println!("分类 -5: {}", classify_number(-5));

    // ----------------------------------------------------------
    // 8. 发散函数（Never Type）
    // ----------------------------------------------------------
    // 返回类型为 ! 的函数永远不会返回
    // 【适用场景】panic!、无限循环、进程退出等
    // fn forever() -> ! { loop {} }
    // fn crash() -> ! { panic!("boom"); }
    println!("发散函数: 返回 ! 类型的函数永远不会正常返回");

    // ----------------------------------------------------------
    // 9. 方法语法预览
    // ----------------------------------------------------------
    // Rust 中的"方法"是在 impl 块中定义的函数
    // 第一个参数是 self（类似 Python 的 self 或 Go 的接收者）
    // 详细内容见结构体章节

    let rect = Rectangle { width: 30, height: 50 };
    println!("矩形面积: {}", rect.area());
    println!("矩形是否为正方形: {}", rect.is_square());

    // 关联函数（不带 self 的函数，类似静态方法）
    let square = Rectangle::new_square(25);
    println!("正方形: {}x{}", square.width, square.height);

    println!("\n=== 函数基础结束 ===");
}

// ----------------------------------------------------------
// 无参数无返回值
// ----------------------------------------------------------
fn say_hello() {
    println!("Hello, Rust!");
}

// ----------------------------------------------------------
// 带参数的函数
// ----------------------------------------------------------
// 【重要】每个参数都必须标注类型
fn greet(name: &str) {
    println!("你好, {}!", name);
}

// ----------------------------------------------------------
// 带返回值的函数
// ----------------------------------------------------------
// 方式1: 隐式返回（最后一个表达式，不加分号）
// 【推荐】Rust 惯用写法
fn add(a: i32, b: i32) -> i32 {
    a + b  // 没有分号！这就是返回值
}

// 方式2: 显式返回（使用 return 关键字）
// 【适用场景】提前返回时使用
fn add_explicit(a: i32, b: i32) -> i32 {
    return a + b;  // 有分号，因为是 return 语句
}

// ----------------------------------------------------------
// 返回元组（多返回值）
// ----------------------------------------------------------
fn sum_and_product(a: i32, b: i32) -> (i32, i32) {
    (a + b, a * b)
}

// ----------------------------------------------------------
// 函数作为参数
// ----------------------------------------------------------
// fn(i32) -> i32 是函数指针类型
fn apply(value: i32, func: fn(i32) -> i32) -> i32 {
    func(value)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn square(x: i32) -> i32 {
    x * x
}

// ----------------------------------------------------------
// 泛型函数
// ----------------------------------------------------------
// T: PartialOrd 表示 T 必须实现了 PartialOrd trait（可比较大小）
fn max_of<T: PartialOrd>(a: T, b: T) -> T {
    if a >= b { a } else { b }
}

// ----------------------------------------------------------
// 提前返回
// ----------------------------------------------------------
fn classify_number(n: i32) -> &'static str {
    if n == 0 {
        return "零";  // 提前返回
    }
    if n > 0 {
        return "正数";
    }
    "负数"  // 最后的隐式返回
}

// ----------------------------------------------------------
// 方法（在 impl 块中定义）
// ----------------------------------------------------------
struct Rectangle {
    width: f64,
    height: f64,
}

impl Rectangle {
    // 方法：第一个参数是 &self（借用自身）
    fn area(&self) -> f64 {
        self.width * self.height
    }

    fn is_square(&self) -> bool {
        (self.width - self.height).abs() < f64::EPSILON
    }

    // 关联函数：没有 self 参数（类似其他语言的静态方法）
    // 调用时使用 :: 语法（如 Rectangle::new_square(5)）
    fn new_square(size: f64) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
