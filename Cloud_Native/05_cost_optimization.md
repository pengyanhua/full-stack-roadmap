# äº‘æˆæœ¬ä¼˜åŒ–

## ç›®å½•
- [æˆæœ¬ä¼˜åŒ–æ¦‚è¿°](#æˆæœ¬ä¼˜åŒ–æ¦‚è¿°)
- [æˆæœ¬åˆ†æ](#æˆæœ¬åˆ†æ)
- [ä¼˜åŒ–ç­–ç•¥](#ä¼˜åŒ–ç­–ç•¥)
- [FinOpså®è·µ](#finopså®è·µ)
- [è‡ªåŠ¨åŒ–å·¥å…·](#è‡ªåŠ¨åŒ–å·¥å…·)

---

## æˆæœ¬ä¼˜åŒ–æ¦‚è¿°

### äº‘æˆæœ¬æµªè´¹çš„ä¸»è¦åŸå› 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          äº‘æˆæœ¬æµªè´¹TOP 10                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚  1. ğŸ’¤ é—²ç½®èµ„æº (35%)                             â”‚
â”‚     æœªå…³é—­çš„å¼€å‘/æµ‹è¯•ç¯å¢ƒ                          â”‚
â”‚                                                    â”‚
â”‚  2. ğŸ“Š è¿‡åº¦é…ç½® (30%)                             â”‚
â”‚     å®ä¾‹è§„æ ¼è¿œè¶…å®é™…éœ€æ±‚                           â”‚
â”‚                                                    â”‚
â”‚  3. ğŸ—„ï¸  ä½æ•ˆå­˜å‚¨ (15%)                            â”‚
â”‚     æœªä½¿ç”¨å­˜å‚¨åˆ†å±‚ã€å¿«ç…§æœªæ¸…ç†                     â”‚
â”‚                                                    â”‚
â”‚  4. ğŸŒ æ•°æ®ä¼ è¾“è´¹ç”¨ (8%)                          â”‚
â”‚     è·¨åŒºåŸŸ/è·¨äº‘ä¼ è¾“                                â”‚
â”‚                                                    â”‚
â”‚  5. ğŸ”„ æœªä½¿ç”¨é¢„ç•™å®ä¾‹ (5%)                        â”‚
â”‚     é•¿æœŸè¿è¡Œèµ„æºæœªè´­ä¹°RI                           â”‚
â”‚                                                    â”‚
â”‚  6. ğŸ“¡ å­¤ç«‹èµ„æº (3%)                              â”‚
â”‚     EBSå·ã€EIPã€è´Ÿè½½å‡è¡¡å™¨                        â”‚
â”‚                                                    â”‚
â”‚  7. ğŸ” ç¼ºä¹ç›‘æ§ (2%)                              â”‚
â”‚     æ— æˆæœ¬å‘Šè­¦æœºåˆ¶                                 â”‚
â”‚                                                    â”‚
â”‚  8. ğŸ—ï¸  æ¶æ„è®¾è®¡ä¸å½“ (1%)                         â”‚
â”‚     æœªä½¿ç”¨Serverlessç­‰ä½æˆæœ¬æ–¹æ¡ˆ                   â”‚
â”‚                                                    â”‚
â”‚  9. ğŸ”‘ æƒé™ç®¡ç†æ··ä¹± (0.5%)                        â”‚
â”‚     å¼€å‘äººå‘˜éšæ„åˆ›å»ºèµ„æº                           â”‚
â”‚                                                    â”‚
â”‚ 10. ğŸ“… æœªå®šæœŸå®¡æŸ¥ (0.5%)                          â”‚
â”‚     æˆæœ¬ä¼˜åŒ–éæŒç»­æ€§å·¥ä½œ                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æˆæœ¬ä¼˜åŒ–é‡‘å­—å¡”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              äº‘æˆæœ¬ä¼˜åŒ–é‡‘å­—å¡”                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚                    â•±â•²                              â”‚
â”‚                   â•±  â•²                             â”‚
â”‚                  â•± æ–‡åŒ– â•²    (5%)                  â”‚
â”‚                 â•±  å˜é©  â•²   FinOpså›¢é˜Ÿ            â”‚
â”‚                â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²                        â”‚
â”‚               â•±            â•²                       â”‚
â”‚              â•±   æ¶æ„ä¼˜åŒ–   â•²  (15%)               â”‚
â”‚             â•±  Serverless   â•² é‡æ„åº”ç”¨             â”‚
â”‚            â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²                      â”‚
â”‚           â•±                  â•²                     â”‚
â”‚          â•±    èµ„æºä¼˜åŒ–        â•² (30%)              â”‚
â”‚         â•±   Right Sizing      â•² é¢„ç•™å®ä¾‹           â”‚
â”‚        â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²                    â”‚
â”‚       â•±                        â•²                   â”‚
â”‚      â•±     æ¸…ç†æµªè´¹èµ„æº         â•² (50%)            â”‚
â”‚     â•±   å…³é—­é—²ç½®/åˆ é™¤å­¤ç«‹èµ„æº    â•² ä½å‚çš„æœå®      â”‚
â”‚    â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²               â”‚
â”‚                                                    â”‚
â”‚  å»ºè®®: ä»åº•å±‚å¼€å§‹ï¼Œå¿«é€Ÿè§æ•ˆï¼                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## æˆæœ¬åˆ†æ

### AWSæˆæœ¬åˆ†æè„šæœ¬

```python
# aws_cost_analyzer.py
import boto3
from datetime import datetime, timedelta
from collections import defaultdict
import pandas as pd

class AWSCostAnalyzer:
    """AWS æˆæœ¬åˆ†æå™¨"""

    def __init__(self, region='us-east-1'):
        self.ce = boto3.client('ce', region_name=region)
        self.ec2 = boto3.client('ec2', region_name=region)
        self.rds = boto3.client('rds', region_name=region)
        self.s3 = boto3.client('s3')

    def get_monthly_cost_by_service(self, months=3):
        """è·å–æœ€è¿‘Nä¸ªæœˆå„æœåŠ¡æˆæœ¬"""
        end = datetime.now()
        start = end - timedelta(days=months * 30)

        response = self.ce.get_cost_and_usage(
            TimePeriod={
                'Start': start.strftime('%Y-%m-%d'),
                'End': end.strftime('%Y-%m-%d')
            },
            Granularity='MONTHLY',
            Metrics=['UnblendedCost'],
            GroupBy=[{'Type': 'DIMENSION', 'Key': 'SERVICE'}]
        )

        # è§£ææ•°æ®
        data = []
        for result in response['ResultsByTime']:
            month = result['TimePeriod']['Start']
            for group in result['Groups']:
                service = group['Keys'][0]
                cost = float(group['Metrics']['UnblendedCost']['Amount'])
                if cost > 0:
                    data.append({
                        'Month': month,
                        'Service': service,
                        'Cost': cost
                    })

        df = pd.DataFrame(data)

        # é€è§†è¡¨
        pivot = df.pivot_table(
            index='Service',
            columns='Month',
            values='Cost',
            aggfunc='sum',
            fill_value=0
        )

        # è®¡ç®—å¢é•¿ç‡
        if len(pivot.columns) >= 2:
            pivot['Growth'] = ((pivot.iloc[:, -1] - pivot.iloc[:, -2]) /
                               pivot.iloc[:, -2] * 100)

        return pivot.sort_values(by=pivot.columns[-1], ascending=False)

    def find_idle_ec2_instances(self):
        """æŸ¥æ‰¾é—²ç½®EC2å®ä¾‹ï¼ˆCPU<5%ï¼‰"""
        cloudwatch = boto3.client('cloudwatch')
        idle_instances = []

        # è·å–æ‰€æœ‰è¿è¡Œä¸­çš„å®ä¾‹
        response = self.ec2.describe_instances(
            Filters=[{'Name': 'instance-state-name', 'Values': ['running']}]
        )

        for reservation in response['Reservations']:
            for instance in reservation['Instances']:
                instance_id = instance['InstanceId']
                instance_type = instance['InstanceType']

                # è·å–è¿‡å»7å¤©çš„CPUä½¿ç”¨ç‡
                metrics = cloudwatch.get_metric_statistics(
                    Namespace='AWS/EC2',
                    MetricName='CPUUtilization',
                    Dimensions=[{'Name': 'InstanceId', 'Value': instance_id}],
                    StartTime=datetime.utcnow() - timedelta(days=7),
                    EndTime=datetime.utcnow(),
                    Period=3600,  # 1å°æ—¶
                    Statistics=['Average']
                )

                if metrics['Datapoints']:
                    avg_cpu = sum(p['Average'] for p in metrics['Datapoints']) / len(metrics['Datapoints'])

                    if avg_cpu < 5:  # CPU < 5%
                        # è®¡ç®—æ¯æœˆæˆæœ¬
                        monthly_cost = self._estimate_instance_cost(instance_type)

                        idle_instances.append({
                            'InstanceId': instance_id,
                            'InstanceType': instance_type,
                            'AvgCPU': f"{avg_cpu:.2f}%",
                            'MonthlyCost': f"${monthly_cost:.2f}",
                            'Tags': {tag['Key']: tag['Value'] for tag in instance.get('Tags', [])}
                        })

        return pd.DataFrame(idle_instances)

    def _estimate_instance_cost(self, instance_type):
        """ä¼°ç®—EC2å®ä¾‹æœˆæˆæœ¬ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        # ç®€åŒ–çš„ä»·æ ¼è¡¨ï¼ˆå®é™…åº”ä½¿ç”¨AWS Pricing APIï¼‰
        prices = {
            't2.micro': 8.47,
            't2.small': 16.79,
            't2.medium': 33.58,
            't3.medium': 30.37,
            't3.large': 60.74,
            'm5.large': 69.35,
            'm5.xlarge': 138.70,
            'c5.large': 61.37,
            'c5.xlarge': 122.74
        }
        return prices.get(instance_type, 100)  # é»˜è®¤$100

    def find_unattached_ebs_volumes(self):
        """æŸ¥æ‰¾æœªæŒ‚è½½çš„EBSå·"""
        response = self.ec2.describe_volumes(
            Filters=[{'Name': 'status', 'Values': ['available']}]
        )

        unattached = []
        for volume in response['Volumes']:
            size_gb = volume['Size']
            volume_type = volume['VolumeType']

            # ä¼°ç®—æœˆæˆæœ¬
            cost_per_gb = {
                'gp2': 0.10,
                'gp3': 0.08,
                'io1': 0.125,
                'io2': 0.125,
                'st1': 0.045,
                'sc1': 0.015
            }.get(volume_type, 0.10)

            monthly_cost = size_gb * cost_per_gb

            unattached.append({
                'VolumeId': volume['VolumeId'],
                'Size': f"{size_gb} GB",
                'Type': volume_type,
                'CreateTime': volume['CreateTime'].strftime('%Y-%m-%d'),
                'MonthlyCost': f"${monthly_cost:.2f}"
            })

        return pd.DataFrame(unattached)

    def find_unassociated_eips(self):
        """æŸ¥æ‰¾æœªå…³è”çš„å¼¹æ€§IP"""
        response = self.ec2.describe_addresses()

        unassociated = []
        for address in response['Addresses']:
            if 'InstanceId' not in address:  # æœªå…³è”
                unassociated.append({
                    'AllocationId': address['AllocationId'],
                    'PublicIp': address['PublicIp'],
                    'MonthlyCost': '$3.60'  # AWSå›ºå®šè´¹ç”¨
                })

        return pd.DataFrame(unassociated)

    def analyze_s3_storage_class(self):
        """åˆ†æS3å­˜å‚¨ç±»åˆ«ä¼˜åŒ–æœºä¼š"""
        opportunities = []

        for bucket in self.s3.list_buckets()['Buckets']:
            bucket_name = bucket['Name']

            try:
                # è·å–å¯¹è±¡åˆ—è¡¨
                paginator = self.s3.get_paginator('list_objects_v2')
                pages = paginator.paginate(Bucket=bucket_name)

                total_size = 0
                old_objects = 0  # 90å¤©æœªè®¿é—®

                for page in pages:
                    if 'Contents' not in page:
                        continue

                    for obj in page['Contents']:
                        size = obj['Size']
                        last_modified = obj['LastModified']
                        storage_class = obj.get('StorageClass', 'STANDARD')

                        total_size += size

                        # 90å¤©æœªä¿®æ”¹çš„å¯¹è±¡
                        age_days = (datetime.now(last_modified.tzinfo) - last_modified).days
                        if age_days > 90 and storage_class == 'STANDARD':
                            old_objects += 1

                if old_objects > 0:
                    # è®¡ç®—èŠ‚çœæˆæœ¬
                    size_gb = total_size / (1024**3)
                    current_cost = size_gb * 0.023  # STANDARD
                    glacier_cost = size_gb * 0.004  # GLACIER
                    savings = (current_cost - glacier_cost) * (old_objects / (total_size / size_gb))

                    opportunities.append({
                        'Bucket': bucket_name,
                        'TotalSize': f"{size_gb:.2f} GB",
                        'OldObjects': old_objects,
                        'PotentialSavings': f"${savings:.2f}/month"
                    })

            except Exception as e:
                print(f"è·³è¿‡æ¡¶ {bucket_name}: {e}")

        return pd.DataFrame(opportunities)

    def generate_report(self):
        """ç”Ÿæˆå®Œæ•´çš„æˆæœ¬ä¼˜åŒ–æŠ¥å‘Š"""
        print("=" * 60)
        print("AWS æˆæœ¬ä¼˜åŒ–æŠ¥å‘Š")
        print("=" * 60)

        # 1. æœˆåº¦æˆæœ¬è¶‹åŠ¿
        print("\nğŸ“Š æœˆåº¦æˆæœ¬ï¼ˆæŒ‰æœåŠ¡ï¼‰")
        print(self.get_monthly_cost_by_service())

        # 2. é—²ç½®EC2å®ä¾‹
        print("\nğŸ’¤ é—²ç½® EC2 å®ä¾‹ï¼ˆCPU < 5%ï¼‰")
        idle_ec2 = self.find_idle_ec2_instances()
        if not idle_ec2.empty:
            print(idle_ec2)
            print(f"\næ½œåœ¨èŠ‚çœ: ${idle_ec2['MonthlyCost'].str.replace('$', '').astype(float).sum():.2f}/æœˆ")
        else:
            print("âœ… æœªå‘ç°é—²ç½®å®ä¾‹")

        # 3. æœªæŒ‚è½½EBSå·
        print("\nğŸ—„ï¸  æœªæŒ‚è½½çš„ EBS å·")
        unattached_ebs = self.find_unattached_ebs_volumes()
        if not unattached_ebs.empty:
            print(unattached_ebs)
            print(f"\næ½œåœ¨èŠ‚çœ: ${unattached_ebs['MonthlyCost'].str.replace('$', '').astype(float).sum():.2f}/æœˆ")
        else:
            print("âœ… æœªå‘ç°æœªæŒ‚è½½å·")

        # 4. æœªå…³è”EIP
        print("\nğŸ“¡ æœªå…³è”çš„å¼¹æ€§ IP")
        unassociated_eips = self.find_unassociated_eips()
        if not unassociated_eips.empty:
            print(unassociated_eips)
            print(f"\næ½œåœ¨èŠ‚çœ: ${len(unassociated_eips) * 3.60:.2f}/æœˆ")
        else:
            print("âœ… æœªå‘ç°æœªå…³è” EIP")

        # 5. S3å­˜å‚¨ä¼˜åŒ–
        print("\nğŸ—‚ï¸  S3 å­˜å‚¨ç±»åˆ«ä¼˜åŒ–æœºä¼š")
        s3_opportunities = self.analyze_s3_storage_class()
        if not s3_opportunities.empty:
            print(s3_opportunities)
        else:
            print("âœ… æœªå‘ç°ä¼˜åŒ–æœºä¼š")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    analyzer = AWSCostAnalyzer()
    analyzer.generate_report()
```

---

## ä¼˜åŒ–ç­–ç•¥

### 1. å®ä¾‹è§„æ ¼ä¼˜åŒ–ï¼ˆRight Sizingï¼‰

```python
# right_sizing.py
import boto3
from datetime import datetime, timedelta

class RightSizingRecommender:
    """EC2 å®ä¾‹è§„æ ¼æ¨è"""

    def __init__(self):
        self.ec2 = boto3.client('ec2')
        self.cloudwatch = boto3.client('cloudwatch')
        self.compute_optimizer = boto3.client('compute-optimizer')

    def get_recommendations(self):
        """è·å– AWS Compute Optimizer æ¨è"""
        try:
            response = self.compute_optimizer.get_ec2_instance_recommendations()

            recommendations = []
            for rec in response['instanceRecommendations']:
                instance_arn = rec['instanceArn']
                current_type = rec['currentInstanceType']

                # æ¨èé€‰é¡¹
                options = rec['recommendationOptions']
                if options:
                    best_option = options[0]  # ç¬¬ä¸€ä¸ªé€šå¸¸æ˜¯æœ€ä½³æ¨è

                    recommendations.append({
                        'InstanceId': instance_arn.split('/')[-1],
                        'Current': current_type,
                        'Recommended': best_option['instanceType'],
                        'CurrentCost': rec.get('currentPerformanceRisk', 'N/A'),
                        'EstimatedSavings': f"${best_option.get('estimatedMonthlySavings', {}).get('value', 0):.2f}",
                        'Reason': self._format_reason(best_option)
                    })

            return recommendations

        except Exception as e:
            print(f"é”™è¯¯: {e}")
            return []

    def _format_reason(self, option):
        """æ ¼å¼åŒ–æ¨èåŸå› """
        utilization = option.get('projectedUtilizationMetrics', [])
        reasons = []

        for metric in utilization:
            name = metric['name']
            value = metric['statistic']

            if name == 'CPU' and float(value) < 40:
                reasons.append(f"CPUä½({value}%)")
            elif name == 'MEMORY' and float(value) < 40:
                reasons.append(f"å†…å­˜ä½({value}%)")

        return ', '.join(reasons) if reasons else 'æ­£å¸¸'

# ä½¿ç”¨ç¤ºä¾‹
recommender = RightSizingRecommender()
recs = recommender.get_recommendations()

for rec in recs:
    print(f"{rec['InstanceId']}: {rec['Current']} â†’ {rec['Recommended']}")
    print(f"  èŠ‚çœ: {rec['EstimatedSavings']}, åŸå› : {rec['Reason']}\n")
```

### 2. è‡ªåŠ¨åŒ–å¯åœç­–ç•¥

```python
# auto_start_stop.py
import boto3
from datetime import datetime

def lambda_handler(event, context):
    """
    Lambda å‡½æ•°ï¼šè‡ªåŠ¨å¯åœ EC2 å®ä¾‹
    é…åˆ EventBridge å®šæ—¶è§¦å‘

    æ ‡ç­¾è§„åˆ™:
    - AutoStop: true (å¯ç”¨è‡ªåŠ¨åœæ­¢)
    - Schedule: weekdays-9to18 (å·¥ä½œæ—¥9ç‚¹åˆ°18ç‚¹)
    """

    ec2 = boto3.client('ec2')

    # è·å–å½“å‰æ—¶é—´
    now = datetime.now()
    hour = now.hour
    weekday = now.weekday()  # 0=å‘¨ä¸€, 6=å‘¨æ—¥

    print(f"å½“å‰æ—¶é—´: {now}, æ˜ŸæœŸ{weekday+1}, {hour}ç‚¹")

    # è·å–æ‰€æœ‰å¸¦è‡ªåŠ¨åœæ­¢æ ‡ç­¾çš„å®ä¾‹
    response = ec2.describe_instances(
        Filters=[
            {'Name': 'tag:AutoStop', 'Values': ['true']},
            {'Name': 'instance-state-name', 'Values': ['running', 'stopped']}
        ]
    )

    instances_to_stop = []
    instances_to_start = []

    for reservation in response['Reservations']:
        for instance in reservation['Instances']:
            instance_id = instance['InstanceId']
            state = instance['State']['Name']
            tags = {tag['Key']: tag['Value'] for tag in instance.get('Tags', [])}

            schedule = tags.get('Schedule', 'weekdays-9to18')

            # è§£ææ—¶é—´è¡¨
            should_run = parse_schedule(schedule, weekday, hour)

            if should_run and state == 'stopped':
                instances_to_start.append(instance_id)
            elif not should_run and state == 'running':
                instances_to_stop.append(instance_id)

    # æ‰§è¡Œå¯åœæ“ä½œ
    if instances_to_stop:
        print(f"åœæ­¢å®ä¾‹: {instances_to_stop}")
        ec2.stop_instances(InstanceIds=instances_to_stop)

    if instances_to_start:
        print(f"å¯åŠ¨å®ä¾‹: {instances_to_start}")
        ec2.start_instances(InstanceIds=instances_to_start)

    return {
        'stopped': len(instances_to_stop),
        'started': len(instances_to_start)
    }

def parse_schedule(schedule, weekday, hour):
    """
    è§£ææ—¶é—´è¡¨
    ç¤ºä¾‹:
    - weekdays-9to18: å·¥ä½œæ—¥9-18ç‚¹
    - weekends-0to24: å‘¨æœ«å…¨å¤©
    - always: å§‹ç»ˆè¿è¡Œ
    """

    if schedule == 'always':
        return True

    parts = schedule.split('-')
    days_part = parts[0]
    hours_part = parts[1] if len(parts) > 1 else '0to24'

    # æ£€æŸ¥æ—¥æœŸ
    if days_part == 'weekdays' and weekday >= 5:  # å‘¨æœ«
        return False
    elif days_part == 'weekends' and weekday < 5:  # å·¥ä½œæ—¥
        return False

    # æ£€æŸ¥å°æ—¶
    start_hour, end_hour = map(int, hours_part.replace('to', ' ').split())
    return start_hour <= hour < end_hour

# EventBridge è§„åˆ™ç¤ºä¾‹
"""
{
  "name": "AutoStopEC2",
  "scheduleExpression": "cron(0 * * * ? *)",  # æ¯å°æ—¶æ‰§è¡Œ
  "state": "ENABLED",
  "targets": [{
    "arn": "arn:aws:lambda:us-east-1:123456:function:AutoStartStop",
    "id": "1"
  }]
}
"""
```

### 3. é¢„ç•™å®ä¾‹åˆ†æå™¨

```python
# reserved_instance_analyzer.py
import boto3
from datetime import datetime, timedelta

class ReservedInstanceAnalyzer:
    """é¢„ç•™å®ä¾‹æ¨èåˆ†æ"""

    def __init__(self):
        self.ce = boto3.client('ce')
        self.ec2 = boto3.client('ec2')

    def analyze_ri_opportunities(self):
        """åˆ†æé¢„ç•™å®ä¾‹è´­ä¹°æœºä¼š"""

        # è·å–è¿‡å»30å¤©çš„å®ä¾‹ä½¿ç”¨æƒ…å†µ
        end = datetime.now()
        start = end - timedelta(days=30)

        response = self.ce.get_reservation_purchase_recommendation(
            Service='Amazon Elastic Compute Cloud - Compute',
            LookbackPeriodInDays='THIRTY_DAYS',
            TermInYears='ONE_YEAR',
            PaymentOption='NO_UPFRONT'
        )

        recommendations = []

        for rec in response['Recommendations']:
            details = rec['RecommendationDetails']

            for detail in details:
                instance_details = detail['InstanceDetails']['EC2InstanceDetails']

                recommendations.append({
                    'InstanceType': instance_details['InstanceType'],
                    'Region': instance_details['Region'],
                    'Quantity': detail['RecommendedNumberOfInstancesToPurchase'],
                    'MonthlySavings': f"${detail['EstimatedMonthlySavingsAmount']:.2f}",
                    'UpfrontCost': f"${detail['UpfrontCost']:.2f}",
                    'BreakEvenMonths': detail['EstimatedBreakEvenInMonths']
                })

        return recommendations

    def calculate_ri_coverage(self):
        """è®¡ç®—å½“å‰RIè¦†ç›–ç‡"""
        end = datetime.now()
        start = end - timedelta(days=7)

        response = self.ce.get_reservation_coverage(
            TimePeriod={
                'Start': start.strftime('%Y-%m-%d'),
                'End': end.strftime('%Y-%m-%d')
            },
            Granularity='DAILY',
            GroupBy=[{'Type': 'DIMENSION', 'Key': 'INSTANCE_TYPE'}]
        )

        coverage_data = []

        for result in response['CoveragesByTime']:
            date = result['TimePeriod']['Start']

            for group in result['Groups']:
                instance_type = group['Attributes']['instanceType']
                coverage = group['Coverage']

                coverage_pct = float(coverage.get('CoverageHours', {}).get('CoverageHoursPercentage', 0))

                if coverage_pct < 80:  # è¦†ç›–ç‡ < 80%
                    coverage_data.append({
                        'Date': date,
                        'InstanceType': instance_type,
                        'Coverage': f"{coverage_pct:.1f}%",
                        'OnDemandHours': coverage['CoverageHours']['OnDemandHours'],
                        'ReservedHours': coverage['CoverageHours']['ReservedHours']
                    })

        return coverage_data

# ä½¿ç”¨ç¤ºä¾‹
analyzer = ReservedInstanceAnalyzer()

print("ğŸ’° é¢„ç•™å®ä¾‹è´­ä¹°å»ºè®®:")
recommendations = analyzer.analyze_ri_opportunities()
for rec in recommendations:
    print(f"  {rec['InstanceType']} x{rec['Quantity']}")
    print(f"    èŠ‚çœ: {rec['MonthlySavings']}/æœˆ")
    print(f"    å›æœ¬å‘¨æœŸ: {rec['BreakEvenMonths']}ä¸ªæœˆ\n")

print("ğŸ“Š å½“å‰ RI è¦†ç›–ç‡:")
coverage = analyzer.calculate_ri_coverage()
for item in coverage:
    print(f"  {item['InstanceType']}: {item['Coverage']}")
```

---

## FinOpså®è·µ

### FinOps ç»„ç»‡ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            FinOps å›¢é˜Ÿç»“æ„                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚         â”‚   FinOps Lead    â”‚                      â”‚
â”‚         â”‚  (CFO/CTOç›´å±)   â”‚                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                  â”‚                                 â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚      â”‚           â”‚           â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”€â”                 â”‚
â”‚  â”‚è´¢åŠ¡  â”‚   â”‚å·¥ç¨‹  â”‚   â”‚ä¸šåŠ¡  â”‚                 â”‚
â”‚  â”‚åˆ†æå¸ˆâ”‚   â”‚è´Ÿè´£äººâ”‚   â”‚è´Ÿè´£äººâ”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                    â”‚
â”‚  èŒè´£:                                             â”‚
â”‚  â€¢ æˆæœ¬å»ºæ¨¡ä¸é¢„æµ‹                                  â”‚
â”‚  â€¢ åˆ¶å®šä¼˜åŒ–ç­–ç•¥                                    â”‚
â”‚  â€¢ è·¨éƒ¨é—¨åè°ƒ                                      â”‚
â”‚  â€¢ æ¨åŠ¨æ–‡åŒ–å˜é©                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æˆæœ¬åˆ†æ‘Šæ¨¡å‹

```python
# cost_allocation.py
import boto3
import pandas as pd

class CostAllocator:
    """æˆæœ¬åˆ†æ‘Šè®¡ç®—"""

    def __init__(self):
        self.ce = boto3.client('ce')

    def allocate_by_tags(self, start_date, end_date):
        """æŒ‰æ ‡ç­¾åˆ†æ‘Šæˆæœ¬"""

        response = self.ce.get_cost_and_usage(
            TimePeriod={'Start': start_date, 'End': end_date},
            Granularity='MONTHLY',
            Metrics=['UnblendedCost'],
            GroupBy=[
                {'Type': 'TAG', 'Key': 'Project'},
                {'Type': 'TAG', 'Key': 'Environment'}
            ]
        )

        # è§£ææ•°æ®
        allocations = []

        for result in response['ResultsByTime']:
            month = result['TimePeriod']['Start']

            for group in result['Groups']:
                tags = group['Keys']
                project = tags[0].split('$')[-1] if len(tags) > 0 else 'Untagged'
                env = tags[1].split('$')[-1] if len(tags) > 1 else 'Unknown'

                cost = float(group['Metrics']['UnblendedCost']['Amount'])

                allocations.append({
                    'Month': month,
                    'Project': project,
                    'Environment': env,
                    'Cost': cost
                })

        df = pd.DataFrame(allocations)

        # é€è§†è¡¨ - æŒ‰é¡¹ç›®æ±‡æ€»
        pivot = df.pivot_table(
            index='Project',
            columns='Environment',
            values='Cost',
            aggfunc='sum',
            fill_value=0,
            margins=True  # æ·»åŠ æ€»è®¡è¡Œ
        )

        return pivot

# ä½¿ç”¨ç¤ºä¾‹
allocator = CostAllocator()
allocation = allocator.allocate_by_tags('2026-01-01', '2026-02-01')

print("ğŸ’¼ æˆæœ¬åˆ†æ‘Šï¼ˆæŒ‰é¡¹ç›®å’Œç¯å¢ƒï¼‰:")
print(allocation)

# è¾“å‡ºç¤ºä¾‹:
"""
Environment    dev     prod   staging    All
Project
ProjectA     125.50  1250.30    50.20  1426.00
ProjectB      80.00   950.00    30.00  1060.00
ProjectC     200.00  2000.00   100.00  2300.00
Untagged      50.00   300.00    20.00   370.00
All          455.50  4500.30   200.20  5156.00
"""
```

---

## æ€»ç»“

### æˆæœ¬ä¼˜åŒ–æ£€æŸ¥æ¸…å•

```
â˜ æ¸…ç†æµªè´¹èµ„æº
  â˜ åœæ­¢é—²ç½® EC2 å®ä¾‹
  â˜ åˆ é™¤æœªæŒ‚è½½ EBS å·
  â˜ é‡Šæ”¾æœªå…³è”å¼¹æ€§ IP
  â˜ æ¸…ç†æ—§å¿«ç…§

â˜ å®ä¾‹è§„æ ¼ä¼˜åŒ–
  â˜ Right Sizing è¯„ä¼°
  â˜ ä½¿ç”¨ Graviton å®ä¾‹ï¼ˆARMï¼‰
  â˜ ä½¿ç”¨ Spot å®ä¾‹ï¼ˆéå…³é”®ï¼‰

â˜ é¢„ç•™å®ä¾‹ä¸èŠ‚çœè®¡åˆ’
  â˜ è´­ä¹° 1å¹´/3å¹´ RI
  â˜ ä½¿ç”¨ Savings Plans

â˜ å­˜å‚¨ä¼˜åŒ–
  â˜ S3 ç”Ÿå‘½å‘¨æœŸç­–ç•¥
  â˜ EBS å·ç±»å‹ä¼˜åŒ–ï¼ˆgp3ï¼‰
  â˜ åˆ é™¤æœªä½¿ç”¨å¿«ç…§

â˜ è‡ªåŠ¨åŒ–ä¸è°ƒåº¦
  â˜ å¼€å‘ç¯å¢ƒè‡ªåŠ¨å¯åœ
  â˜ Auto Scaling é…ç½®

â˜ ç›‘æ§ä¸æ²»ç†
  â˜ æˆæœ¬å‘Šè­¦é…ç½®
  â˜ é¢„ç®—è®¾ç½®
  â˜ æ ‡ç­¾ç­–ç•¥æ‰§è¡Œ

â˜ æ¶æ„ä¼˜åŒ–
  â˜ è€ƒè™‘ Serverless
  â˜ ä½¿ç”¨æ‰˜ç®¡æœåŠ¡
  â˜ CDN åŠ é€Ÿ

â˜ FinOps æ–‡åŒ–
  â˜ æˆæœ¬å¯è§æ€§
  â˜ å›¢é˜ŸåŸ¹è®­
  â˜ å®šæœŸ Review
```

### ä¸‹ä¸€æ­¥

æˆæœ¬ä¼˜åŒ–æ˜¯æŒç»­æ€§å·¥ä½œï¼Œå»ºè®®ï¼š
1. æ¯å‘¨æŸ¥çœ‹æˆæœ¬è¶‹åŠ¿
2. æ¯æœˆæ‰§è¡Œä¼˜åŒ– Review
3. æ¯å­£åº¦æ›´æ–°é¢„ç•™å®ä¾‹
4. æ¯å¹´è¯„ä¼°æ¶æ„è®¾è®¡

**äº‘æˆæœ¬ = äº‘èµ„æº Ã— å•ä»· Ã— æ—¶é—´**

ä¼˜åŒ–ä»»ä¸€å› ç´ éƒ½èƒ½é™ä½æˆæœ¬ï¼
