# 传输层协议 (TCP/UDP)

## 一、TCP 协议

### TCP 报文段结构

```
TCP 报文段格式:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          源端口 (16位)        |        目标端口 (16位)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        序列号 (32位)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      确认号 (32位)                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|数据 |保留 |U|A|P|R|S|F|                                       |
|偏移 |(6位)|R|C|S|S|Y|I|            窗口大小 (16位)            |
|(4位)|     |G|K|H|T|N|N|                                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          校验和 (16位)        |        紧急指针 (16位)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    选项 (可变长度)                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        数据                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

字段说明:
├─ 源端口/目标端口 (各16位): 标识应用程序
├─ 序列号 (32位): 本报文段数据的第一个字节的序号
├─ 确认号 (32位): 期望收到的下一个字节的序号
├─ 数据偏移 (4位): TCP头部长度 (20-60字节)
├─ 保留 (6位): 未来使用
├─ 标志位 (6位):
│  ├─ URG: 紧急指针有效
│  ├─ ACK: 确认号有效
│  ├─ PSH: 推送数据到应用层
│  ├─ RST: 重置连接
│  ├─ SYN: 同步序号,建立连接
│  └─ FIN: 结束连接
├─ 窗口大小 (16位): 接收窗口,流量控制
├─ 校验和 (16位): 错误检测
├─ 紧急指针 (16位): URG=1时有效
└─ 选项: MSS, 窗口扩大, 时间戳等
```

### TCP 三次握手

```
TCP 连接建立 (Three-Way Handshake):

客户端                                     服务器
   │                                          │
   │  [1] SYN, seq=x                          │
   │ ──────────────────────────────────────►  │
   │                                          │ LISTEN → SYN_RCVD
   │                                          │
   │  [2] SYN+ACK, seq=y, ack=x+1             │
   │ ◄────────────────────────────────────── │
   │                                          │
SYN_SENT → ESTABLISHED                        │
   │                                          │
   │  [3] ACK, seq=x+1, ack=y+1               │
   │ ──────────────────────────────────────►  │
   │                                          │ SYN_RCVD → ESTABLISHED
   │                                          │
   │ ◄════════════ 数据传输 ═══════════════►  │
   │                                          │

详细步骤:
[1] 第一次握手:
    ├─ 客户端发送 SYN=1, seq=x
    ├─ 请求建立连接
    └─ 客户端进入 SYN_SENT 状态

[2] 第二次握手:
    ├─ 服务器发送 SYN=1, ACK=1, seq=y, ack=x+1
    ├─ 确认客户端的 SYN
    ├─ 同时发送自己的 SYN
    └─ 服务器进入 SYN_RCVD 状态

[3] 第三次握手:
    ├─ 客户端发送 ACK=1, seq=x+1, ack=y+1
    ├─ 确认服务器的 SYN
    ├─ 客户端进入 ESTABLISHED 状态
    └─ 服务器收到后进入 ESTABLISHED 状态

为什么需要三次握手?
├─ 防止旧的重复连接初始化
├─ 双方都确认对方的接收和发送能力
└─ 协商初始序列号

SYN 洪水攻击 (SYN Flood):
├─ 攻击者发送大量 SYN,不响应 SYN+ACK
├─ 服务器维持大量半连接状态
├─ 防御: SYN Cookie, 增加半连接队列
```

### TCP 四次挥手

```
TCP 连接终止 (Four-Way Handshake):

客户端                                     服务器
   │                                          │
   │  [1] FIN, seq=x                          │
   │ ──────────────────────────────────────►  │
   │                                          │
FIN_WAIT_1                                    │ CLOSE_WAIT
   │                                          │
   │  [2] ACK, ack=x+1                        │
   │ ◄────────────────────────────────────── │
   │                                          │
FIN_WAIT_2                                    │
   │                                          │
   │  [3] FIN, seq=y                          │
   │ ◄────────────────────────────────────── │
   │                                          │
TIME_WAIT                                     │ LAST_ACK
   │                                          │
   │  [4] ACK, ack=y+1                        │
   │ ──────────────────────────────────────►  │
   │                                          │
   │ (等待 2MSL)                              │ CLOSED
   │                                          │
CLOSED                                        │

详细步骤:
[1] 第一次挥手:
    ├─ 客户端发送 FIN=1, seq=x
    ├─ 表示没有数据要发送了
    └─ 客户端进入 FIN_WAIT_1

[2] 第二次挥手:
    ├─ 服务器发送 ACK=1, ack=x+1
    ├─ 确认客户端的 FIN
    ├─ 服务器进入 CLOSE_WAIT (可以继续发送数据)
    └─ 客户端进入 FIN_WAIT_2

[3] 第三次挥手:
    ├─ 服务器发送 FIN=1, seq=y
    ├─ 服务器也没有数据要发送了
    └─ 服务器进入 LAST_ACK

[4] 第四次挥手:
    ├─ 客户端发送 ACK=1, ack=y+1
    ├─ 客户端进入 TIME_WAIT,等待 2MSL
    └─ 服务器收到后进入 CLOSED

为什么需要四次挥手?
├─ TCP 是全双工,需要双方都关闭
├─ 第二、三次挥手可能间隔较长(服务器还有数据要发)
└─ TIME_WAIT 确保最后的 ACK 能到达

TIME_WAIT 状态:
├─ 持续时间: 2MSL (Maximum Segment Lifetime, 通常 2分钟)
├─ 作用:
│  ├─ 确保最后的 ACK 到达
│  └─ 防止旧连接的延迟数据影响新连接
└─ 问题: 大量 TIME_WAIT 占用端口资源
```

### TCP 可靠传输

```
TCP 可靠性机制:

1. 序列号和确认号:
   ┌────────────────────────────────────────────────────────┐
   │  发送方                              接收方            │
   │    │ seq=1, 数据[1-100]                │              │
   │    │───────────────────────────────────►              │
   │    │                                    │              │
   │    │              ack=101 (期望101)     │              │
   │    │◄──────────────────────────────────│              │
   │    │ seq=101, 数据[101-200]             │              │
   │    │───────────────────────────────────►              │
   │    │              ack=201               │              │
   │    │◄──────────────────────────────────│              │
   └────────────────────────────────────────────────────────┘

2. 超时重传 (Retransmission):
   ┌────────────────────────────────────────────────────────┐
   │  发送方                              接收方            │
   │    │ seq=1, 数据                       │              │
   │    │───────────X (丢失)                               │
   │    │                                                   │
   │    │ (超时)                                           │
   │    │ seq=1, 数据 (重传)                 │              │
   │    │───────────────────────────────────►              │
   │    │              ack=101               │              │
   │    │◄──────────────────────────────────│              │
   └────────────────────────────────────────────────────────┘

   RTO (Retransmission Timeout) 计算:
   ├─ 基于 RTT (往返时间) 动态计算
   ├─ RTT 估计: SRTT = (1-α)×SRTT + α×RTT_sample
   └─ RTO = SRTT + 4×RTTVAR

3. 快速重传 (Fast Retransmit):
   ┌────────────────────────────────────────────────────────┐
   │  发送方                              接收方            │
   │    │ seq=1, 数据[1-100]                │              │
   │    │───────────────────────────────────►              │
   │    │              ack=101               │              │
   │    │◄──────────────────────────────────│              │
   │    │                                    │              │
   │    │ seq=101, 数据[101-200]             │              │
   │    │───────────X (丢失)                               │
   │    │                                    │              │
   │    │ seq=201, 数据[201-300]             │              │
   │    │───────────────────────────────────►              │
   │    │              ack=101 (重复ACK)     │              │
   │    │◄──────────────────────────────────│              │
   │    │                                    │              │
   │    │ seq=301, 数据[301-400]             │              │
   │    │───────────────────────────────────►              │
   │    │              ack=101 (重复ACK)     │              │
   │    │◄──────────────────────────────────│              │
   │    │                                    │              │
   │    │ seq=401, 数据[401-500]             │              │
   │    │───────────────────────────────────►              │
   │    │              ack=101 (重复ACK #3)  │              │
   │    │◄──────────────────────────────────│              │
   │    │                                    │              │
   │    │ 收到3个重复ACK,快速重传!           │              │
   │    │ seq=101, 数据[101-200] (重传)      │              │
   │    │───────────────────────────────────►              │
   │    │              ack=501               │              │
   │    │◄──────────────────────────────────│              │
   └────────────────────────────────────────────────────────┘

   规则: 收到3个重复ACK,立即重传

4. 选择确认 (SACK):
   ├─ 标准 TCP: 累计确认
   ├─ SACK: 可以确认不连续的数据段
   └─ 选项: TCP 选项中携带 SACK 块
```

### TCP 流量控制

```
滑动窗口 (Sliding Window):

发送方窗口:
┌───────────────────────────────────────────────────────────┐
│  已发送已确认  │  已发送未确认  │  可发送  │  不可发送   │
├───────────────┼────────────────┼──────────┼─────────────┤
│    1-100      │    101-150     │  151-200 │    201+     │
└───────────────┴────────────────┴──────────┴─────────────┘
                ◄────── 发送窗口 ─────────►
                      (rwnd = 100)

接收方窗口:
┌───────────────────────────────────────────────────────────┐
│  已接收已确认  │  可接收  │  不可接收                     │
├───────────────┼──────────┼─────────────────────────────┤
│    1-100      │  101-200 │    201+                      │
└───────────────┴──────────┴──────────────────────────────┘
                ◄─ 接收窗口 ─►
                   (rwnd = 100)

流量控制过程:
发送方                                         接收方
   │                                              │ rwnd=1000
   │ [1] 发送 200 字节                            │
   │──────────────────────────────────────────►   │
   │                                              │ rwnd=800
   │ [2] ACK, rwnd=800                            │
   │◄─────────────────────────────────────────────│
   │                                              │
   │ [3] 发送 800 字节                            │
   │──────────────────────────────────────────►   │
   │                                              │ rwnd=0
   │ [4] ACK, rwnd=0 (接收缓冲区满)               │
   │◄─────────────────────────────────────────────│
   │                                              │
   │ (停止发送,等待窗口更新)                      │
   │                                              │
   │ [5] 定期发送探测包                           │
   │──────────────────────────────────────────►   │
   │                                              │ rwnd=500
   │ [6] ACK, rwnd=500 (应用读取了数据)           │
   │◄─────────────────────────────────────────────│
   │                                              │
   │ [7] 继续发送                                 │
   │──────────────────────────────────────────►   │

零窗口问题:
├─ 接收方 rwnd=0,发送方停止发送
├─ 发送方定期发送探测包 (Zero Window Probe)
└─ 接收方响应窗口更新
```

### TCP 拥塞控制

```
拥塞控制算法:

1. 慢启动 (Slow Start):
   ├─ cwnd (拥塞窗口) 从 1 MSS 开始
   ├─ 每收到一个 ACK,cwnd += 1
   ├─ 指数增长: 1 → 2 → 4 → 8 → 16 ...
   └─ 达到 ssthresh (慢启动阈值) 后,进入拥塞避免

2. 拥塞避免 (Congestion Avoidance):
   ├─ cwnd 线性增长
   ├─ 每个 RTT,cwnd += 1
   └─ 探测可用带宽

3. 快速恢复 (Fast Recovery):
   ├─ 收到 3 个重复 ACK 时
   ├─ ssthresh = cwnd / 2
   ├─ cwnd = ssthresh + 3
   └─ 避免进入慢启动

拥塞窗口变化图:
cwnd
 ▲
 │         拥塞避免
 │        ╱
 │       ╱
 │      ╱         快速恢复
 │     ╱         ╱
 │    ╱         ╱
 │   ╱   超时  ╱  3个重复ACK
 │  ╱         ╱
 │ ╱         ╱
 │╱慢启动   ╱
 └─────────────────────────────────────► 时间
     │         │         │
  ssthresh  超时    3重复ACK

TCP Reno 算法状态转换:
慢启动 ──cwnd≥ssthresh───► 拥塞避免
  ▲  │                        │
  │  │超时                    │3个重复ACK
  │  ▼                        ▼
  └─────────────────────► 快速恢复

发送窗口 = min(cwnd, rwnd)
├─ cwnd: 拥塞窗口 (网络限制)
└─ rwnd: 接收窗口 (接收方限制)
```

## 二、UDP 协议

### UDP 报文格式

```
UDP 数据报格式:

 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|     源端口      |    目标端口     |
+--------+--------+--------+--------+
|     长度        |     校验和      |
+--------+--------+--------+--------+
|                                   |
|            数据                   |
|                                   |
+-----------------------------------+

字段说明:
├─ 源端口 (16位): 可选,无需回复时可为 0
├─ 目标端口 (16位): 必需
├─ 长度 (16位): UDP 头部 + 数据的总长度 (最小 8 字节)
└─ 校验和 (16位): 可选 (IPv4), 包括伪头部

UDP 特点:
├─ 无连接: 不需要建立连接
├─ 不可靠: 不保证数据到达、顺序、不重复
├─ 无拥塞控制: 发送速率不受网络状况影响
├─ 头部开销小: 只有 8 字节
├─ 面向数据报: 每个数据报独立
└─ 支持一对一、一对多、多对多

UDP 适用场景:
├─ 实时应用: 语音、视频通话 (VoIP, WebRTC)
├─ 流媒体: 视频直播 (丢帧可接受)
├─ 在线游戏: 低延迟比可靠性重要
├─ DNS 查询: 请求/响应短小
├─ DHCP: 获取 IP 地址
└─ SNMP: 网络管理

TCP vs UDP 对比:
┌────────────────┬─────────────┬──────────────┐
│      特性      │     TCP     │     UDP      │
├────────────────┼─────────────┼──────────────┤
│   连接         │ 面向连接    │ 无连接       │
│   可靠性       │ 可靠        │ 不可靠       │
│   顺序         │ 有序        │ 无序         │
│   头部大小     │ 20-60字节   │ 8字节        │
│   速度         │ 较慢        │ 快           │
│   拥塞控制     │ 有          │ 无           │
│   流量控制     │ 有          │ 无           │
│   应用场景     │ 可靠传输    │ 实时通信     │
└────────────────┴─────────────┴──────────────┘
```

### UDP 编程示例

```python
# UDP 服务器 (Python)
import socket

# 创建 UDP socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 绑定地址和端口
server_socket.bind(('0.0.0.0', 8888))

print("UDP服务器启动,监听端口 8888")

while True:
    # 接收数据 (非阻塞)
    data, client_addr = server_socket.recvfrom(1024)
    print(f"收到来自 {client_addr} 的数据: {data.decode()}")

    # 发送响应
    response = f"已收到: {data.decode()}"
    server_socket.sendto(response.encode(), client_addr)

# UDP 客户端 (Python)
import socket

# 创建 UDP socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 服务器地址
server_addr = ('localhost', 8888)

# 发送数据
message = "Hello, UDP Server!"
client_socket.sendto(message.encode(), server_addr)

# 接收响应
data, addr = client_socket.recvfrom(1024)
print(f"收到响应: {data.decode()}")

client_socket.close()
```

## 三、端口复用与NAT穿透

### SO_REUSEADDR 和 SO_REUSEPORT

```
端口复用选项:

SO_REUSEADDR:
├─ 允许绑定到 TIME_WAIT 状态的端口
├─ 允许多个 socket 绑定到同一地址(不同端口)
├─ 用于服务器快速重启
└─ Linux/Unix 默认行为

SO_REUSEPORT:
├─ 允许多个 socket 绑定到完全相同的地址和端口
├─ 内核负载均衡分发连接
├─ 用于多进程/多线程服务器
└─ Linux 3.9+ 支持

示例 (Python):
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 设置 SO_REUSEADDR
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# 设置 SO_REUSEPORT (Linux)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)

sock.bind(('0.0.0.0', 8080))
sock.listen(5)
```

### NAT 穿透

```
NAT 穿透技术:

1. STUN (Session Traversal Utilities for NAT):
   ├─ 客户端向 STUN 服务器查询公网 IP 和端口
   ├─ 适用于 Full Cone NAT 和 Restricted Cone NAT
   └─ WebRTC 常用

2. TURN (Traversal Using Relays around NAT):
   ├─ 通过中继服务器转发数据
   ├─ 适用于对称 NAT
   └─ 作为 STUN 的后备方案

3. UPnP (Universal Plug and Play):
   ├─ 自动配置路由器端口映射
   ├─ 不安全,可能被禁用
   └─ P2P 应用常用

4. UDP 打洞 (UDP Hole Punching):
   ├─ 利用 NAT 的对称性
   ├─ 需要第三方服务器协助
   └─ P2P 通信核心技术

UDP 打洞示例:
   客户端A            STUN服务器           客户端B
  (内网192.168.1.10)                    (内网10.0.0.20)
  (公网1.2.3.4:5000)                    (公网5.6.7.8:6000)
       │                                      │
       │ [1] 注册                             │
       │────────────────►                     │
       │                ◄────────────────────│ [1] 注册
       │                                      │
       │ [2] 查询B的公网地址                  │
       │────────────────►                     │
       │   返回: 5.6.7.8:6000                │
       │◄───────────────│                     │
       │                                      │
       │ [3] 向 5.6.7.8:6000 发送 UDP         │
       │─────────────────────────────────────►│
       │                                      │
       │ ◄═════════ P2P 直连建立 ═══════════►│
```

这是传输层协议(TCP/UDP)的完整教程,涵盖了TCP的可靠性机制、流量控制、拥塞控制,以及UDP的特点和应用场景。