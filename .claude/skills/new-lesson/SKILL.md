---
name: new-lesson
description: 向已有模块添加新的课程文件。当用户要求编写某个具体知识点的教学代码时使用。例如"在 Go 并发章节添加 context 的教程"、"写一个 Python 装饰器的课程"。
argument-hint: <模块/子目录> <主题>
disable-model-invocation: true
allowed-tools: Read, Write, Bash, Glob, Grep
---

# 添加新课程

向已有学习模块添加一个新的课程文件。

## 参数

- `$ARGUMENTS` — 格式为 `<模块/子目录> <主题>`，例如：
  - `Go/04-concurrency context用法`
  - `Python/02-functions lambda表达式`
  - `Java/07-modern record类`

## 项目约定

### 文件编号

查看目标目录中已有文件，新文件编号 = 最大编号 + 1。例如目录中已有 `01_goroutines.go`、`02_channels.go`、`03_patterns.go`，则新文件为 `04_<name>.go`。

### 文件命名

`XX_topic_name.<ext>`（数字前缀 + 下划线 + snake_case + 语言扩展名）

语言扩展名映射：
- Go → `.go`
- Python → `.py`
- Java → `.java`
- JavaScript → `.js`
- React → `.jsx`
- Vue → `.vue`
- TypeScript → `.ts`

### 代码风格（极其重要）

参考已有文件的风格，必须严格遵循：

1. **文件头部**：使用 `====` 大分隔符标记文件主题
2. **章节划分**：使用 `----` 小分隔符划分小节
3. **注释语言**：全部使用中文
4. **注释风格**：详细、教学向，解释"为什么"而不只是"是什么"
5. **代码组织**：从简单到复杂递进
6. **可运行**：每个文件必须是完整的、可直接运行的程序

### 代码模板（以 Go 为例）

```go
package main

import (
	"fmt"
)

// ============================================================
//                      主题名称
// ============================================================
// 对该主题的总体介绍，2-3 行

func main() {
	fmt.Println("=== 主题名称 ===")

	// ----------------------------------------------------------
	// 1. 第一个小节
	// ----------------------------------------------------------
	// 详细解释

	// 示例代码...

	// ----------------------------------------------------------
	// 2. 第二个小节
	// ----------------------------------------------------------
	// 详细解释

	// 示例代码...
}

// 辅助函数放在 main 后面
func helperFunc() {
	// ...
}
```

## 执行步骤

1. **解析参数**：确定目标模块、子目录和主题
2. **读取已有文件**：确定编号，理解已有内容避免重复
3. **参考同目录风格**：读取同目录至少一个文件，严格模仿其注释和代码风格
4. **编写课程代码**：
   - 完整的、可运行的代码
   - 详细的中文注释
   - 从基础到进阶的递进结构
   - 包含实际使用示例
   - 涵盖常见陷阱和最佳实践
5. **验证**：如果是 Go 文件检查语法 (`go vet`)，Python 文件检查语法 (`python -c "import ast; ast.parse(open('file').read())"`)
6. **提示后续**：提醒用户运行 `npm run convert` 更新文档
